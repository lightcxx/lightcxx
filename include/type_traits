#ifndef __LIGHTCXX_GUARD_TYPE_TRAITS
#define __LIGHTCXX_GUARD_TYPE_TRAITS

namespace std {

using size_t = decltype(sizeof(void*));
using nullptr_t = decltype(nullptr);

// region [meta.help]

template<class _T, _T _V>
struct integral_constant {
    static inline constexpr _T value = _V;

    using value_type = _T;

    using type = integral_constant<_T, _V>;

    constexpr operator value_type() const noexcept {
        return value;
    }

    constexpr value_type operator()() const noexcept {
        return value;
    }
};

template<bool _B>
using bool_constant = integral_constant<bool, _B>;

using true_type = bool_constant<true>;

using false_type = bool_constant<false>;

// endregion

// region std::is_same, std::same_as

template<class _T, class _U>
struct is_same : false_type {};

template<class _T>
struct is_same<_T, _T> : true_type {};

template<class _T, class _U>
inline constexpr bool is_same_v = false;

template<class _T>
inline constexpr bool is_same_v<_T, _T> = true;

template<class _T, class _U>
concept same_as = is_same_v<_T, _U>;

// endregion

// region implementation-details

namespace _Light {
    template<class _T>
    inline constexpr bool _False = false;

    template<class _T>
    using _NonSfinaeAddReference = _T&;

    template<class _T>
    concept _Referenceable = requires {
        typename _NonSfinaeAddReference<_T>;
    };

    template<class _T>
    _T&& __declval_impl(int);

    template<class _T>
    _T __declval_impl(long);
};  // namespace _Light

#define __UNARY_TRAIT_TRUE_FOR_ALL_CV(_Trait, _T)                                                  \
    template<>                                                                                     \
    struct _Trait<_T> : ::std::true_type {};                                                       \
    template<>                                                                                     \
    struct _Trait<_T const> : ::std::true_type {};                                                 \
    template<>                                                                                     \
    struct _Trait<_T volatile> : ::std::true_type {};                                              \
    template<>                                                                                     \
    struct _Trait<_T const volatile> : ::std::true_type {}

#ifdef _LIGHTCXX_DONT_USE_BUILTINS
#define __LIGHTCXX_USE_BUILTIN(_B) 0
#else
#define __LIGHTCXX_USE_BUILTIN(_B) (defined(_B) || (defined(__has_builtin) && __has_builtin(_B)))
#endif

// endregion

// region forward-decls
template<class _T>
struct remove_reference;

template<class _T>
struct is_lvalue_reference;

template<class _T>
struct is_const;

template<class _T>
struct remove_cv;

template<class _T>
struct add_pointer;

template<class _T>
struct add_lvalue_reference;

template<class _T>
struct add_rvalue_reference;

template<class _T>
struct remove_cv;

template<class _T>
struct remove_all_extents;

template<class _T>
struct is_swappable;

template<class _T>
struct is_nothrow_swappable;

template<bool _B, class _T, class _F>
struct conditional;

template<class _T>
struct decay;

template<class _T>
struct reference_wrapper;
// endregion

// region utility-core

template<class _T>
decltype(_Light::__declval_impl<_T>(0)) declval() noexcept;

template<class _T>
constexpr auto forward(typename remove_reference<_T>::type& __t) noexcept {
    return static_cast<_T&&>(__t);
}

template<class _T>
constexpr auto forward(typename remove_reference<_T>::type&& __t) noexcept {
    static_assert(!is_lvalue_reference<_T>::value, "can not forward an rvalue as an lvalue");
    return static_cast<_T&&>(__t);
}

template<class _T>
constexpr auto move(_T&& __t) noexcept {
    return static_cast<typename remove_reference<_T>::type&&>(__t);
}

// endregion

// region [meta.unary.cat]

// region is_void
#if __LIGHTCXX_USE_BUILTIN(__is_void)

template<class _T>
struct is_void : bool_constant<__is_void(_T)> {};

template<class _T>
inline constexpr bool is_void_v = __is_void(_T);

#else

template<class _T>
struct is_void : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_void, void);

template<class _T>
inline constexpr bool is_void_v = is_void<_T>::value;

#endif  // endregion

// region is_null_pointer
template<class _T>
struct is_null_pointer : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_null_pointer, nullptr_t);

template<class _T>
inline constexpr bool is_null_pointer_v = is_null_pointer<_T>::value;
// endregion

// region is_integral
#if __LIGHTCXX_USE_BUILTIN(__is_integral)

template<class _T>
struct is_integral : bool_constant<__is_integral(_T)> {};

template<class _T>
inline constexpr bool is_integral_v = __is_integral(_T);

#else

template<class _T>
struct is_integral : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, bool);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, wchar_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char8_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char16_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char32_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, signed char);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, short);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, long int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, long long int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned char);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned short int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned long int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned long long int);

template<class _T>
inline constexpr bool is_integral_v = is_integral<_T>::value;

#endif  // endregion

// region is_floating_point
#if __LIGHTCXX_USE_BUILTIN(__is_floating_point)

template<class _T>
struct is_floating_point : bool_constant<__is_floating_point(_T)> {};

template<class _T>
inline constexpr bool is_floating_point_v = __is_floating_point(_T);

#else

template<class _T>
struct is_floating_point : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_floating_point, float);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_floating_point, double);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_floating_point, long double);

template<class _T>
inline constexpr bool is_floating_point_v = is_floating_point<_T>::value;

#endif  // endregion

// region is_array
#if __LIGHTCXX_USE_BUILTIN(__is_array)

template<class _T>
struct is_array : bool_constant<__is_array(_T)> {};

template<class _T>
inline constexpr bool is_array_v = __is_array(_T);

#else

template<class _T>
struct is_array : false_type {};

template<class _T>
struct is_array<_T[]> : true_type {};

template<class _T, size_t _N>
struct is_array<_T[_N]> : true_type {};

template<class _T>
inline constexpr bool is_array_v = is_array<_T>::value;

#endif  // endregion

// region is_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_pointer)

template<class _T>
struct is_pointer : bool_constant<__is_pointer(_T)> {};

template<class _T>
inline constexpr bool is_pointer_v = __is_pointer(_T);

#else

template<class _T>
struct is_pointer : false_type {};

template<class _T>
struct is_pointer<_T*> : true_type {};

template<class _T>
struct is_pointer<_T* const> : true_type {};

template<class _T>
struct is_pointer<_T* volatile> : true_type {};

template<class _T>
struct is_pointer<_T* const volatile> : true_type {};

template<class _T>
inline constexpr bool is_pointer_v = is_pointer<_T>::value;

#endif  // endregion

// region is_lvalue_reference
#if __LIGHTCXX_USE_BUILTIN(__is_lvalue_reference)

template<class _T>
struct is_lvalue_reference : bool_constant<__is_lvalue_reference(_T)> {};

template<class _T>
inline constexpr bool is_lvalue_reference_v = __is_lvalue_reference(_T);

#else

template<class _T>
struct is_lvalue_reference : false_type {};

template<class _T>
struct is_lvalue_reference<_T&> : true_type {};

template<class _T>
inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<_T>::value;

#endif  // endregion

// region is_rvalue_reference
#if __LIGHTCXX_USE_BUILTIN(__is_rvalue_reference)

template<class _T>
struct is_rvalue_reference : bool_constant<__is_rvalue_reference(_T)> {};

template<class _T>
inline constexpr bool is_rvalue_reference_v = __is_rvalue_reference(_T);

#else

template<class _T>
struct is_rvalue_reference : false_type {};

template<class _T>
struct is_rvalue_reference<_T&&> : true_type {};

template<class _T>
inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<_T>::value;

#endif  // endregion

// region is_function
#if __LIGHTCXX_USE_BUILTIN(__is_function)

template<class _T>
struct is_function : bool_constant<__is_function(_T)> {};

template<class _T>
inline constexpr bool is_function_v = __is_function(_T);

#else

template<class _T>
inline constexpr bool is_function_v
  = !is_const<const _T>::value && !is_lvalue_reference_v<_T> && !is_rvalue_reference_v<_T>;

template<class _T>
struct is_function : bool_constant<is_function_v<_T>> {};

#endif  // endregion

// region is_member_object_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_member_object_pointer)

template<class _T>
struct is_member_object_pointer : bool_constant<__is_member_object_pointer(_T)> {};

template<class _T>
inline constexpr bool is_member_object_pointer_v = __is_member_object_pointer(_T);

#else

template<class _T>
struct is_member_object_pointer : false_type {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*> : bool_constant<!is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*const> : bool_constant<!is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*volatile> : bool_constant<!is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*const volatile> : bool_constant<!is_function_v<_T>> {};

template<class _T>
inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<_T>::value;

#endif  // endregion

// region is_member_function_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_member_function_pointer)

template<class _T>
struct is_member_function_pointer : bool_constant<__is_member_function_pointer(_T)> {};

template<class _T>
inline constexpr bool is_member_function_pointer_v = __is_member_function_pointer(_T);

#else

template<class _T>
struct is_member_function_pointer : false_type {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*> : bool_constant<is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*const> : bool_constant<is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*volatile> : bool_constant<is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*const volatile> : bool_constant<is_function_v<_T>> {};

template<class _T>
inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<_T>::value;

#endif  // endregion

// region is_enum
#if __LIGHTCXX_USE_BUILTIN(__is_enum)

template<class _T>
struct is_enum : bool_constant<__is_enum(_T)> {};

template<class _T>
inline constexpr bool is_enum_v = __is_enum(_T);

#else

template<class _T>
struct is_enum : false_type {
    static_assert(_Light::_False<_T>, "std::is_enum is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_enum_v = is_enum<_T>::value;

#endif  // endregion

// region is_union
#if __LIGHTCXX_USE_BUILTIN(__is_union)

template<class _T>
struct is_union : bool_constant<__is_union(_T)> {};

template<class _T>
inline constexpr bool is_union_v = __is_union(_T);

#else

template<class _T>
struct is_union : false_type {
    static_assert(_Light::_False<_T>, "std::is_union is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_union_v = is_union<_T>::value;

#endif  // endregion

// region is_class
#if __LIGHTCXX_USE_BUILTIN(__is_class)

template<class _T>
struct is_class : bool_constant<__is_class(_T)> {};

template<class _T>
inline constexpr bool is_class_v = __is_class(_T);

#else

template<class _T>
struct is_class : false_type {
    static_assert(_Light::_False<_T>, "std::is_class is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_class_v = is_class<_T>::value;

#endif  // endregion

// endregion

// region [meta.unary.comp]

// region is_reference
#if __LIGHTCXX_USE_BUILTIN(__is_reference)

template<class _T>
struct is_reference : bool_constant<__is_reference(_T)> {};

template<class _T>
inline constexpr bool is_reference_v = __is_reference(_T);

#else

template<class _T>
struct is_reference : false_type {};

template<class _T>
struct is_reference<_T&> : true_type {};

template<class _T>
struct is_reference<_T&&> : true_type {};

template<class _T>
inline constexpr bool is_reference_v = is_reference<_T>::value;

#endif  // endregion

// region is_arithmetic
#if __LIGHTCXX_USE_BUILTIN(__is_arithmetic)

template<class _T>
struct is_arithmetic : bool_constant<__is_arithmetic(_T)> {};

template<class _T>
inline constexpr bool is_arithmetic_v = __is_arithmetic(_T);

#else

template<class _T>
inline constexpr bool is_arithmetic_v = is_integral_v<_T> || is_floating_point_v<_T>;

template<class _T>
struct is_arithmetic : bool_constant<is_arithmetic_v<_T>> {};

#endif  // endregion

// region is_fundamental
#if __LIGHTCXX_USE_BUILTIN(__is_fundamental)

template<class _T>
struct is_fundamental : bool_constant<__is_fundamental(_T)> {};

template<class _T>
inline constexpr bool is_fundamental_v = __is_fundamental(_T);

#else

template<class _T>
inline constexpr bool is_fundamental_v
  = is_void_v<_T> || is_null_pointer_v<_T> || is_integral_v<_T> || is_floating_point_v<_T>;

template<class _T>
struct is_fundamental : bool_constant<is_fundamental_v<_T>> {};

#endif  // endregion

// region is_object
#if __LIGHTCXX_USE_BUILTIN(__is_object)

template<class _T>
struct is_object : bool_constant<__is_object(_T)> {};

template<class _T>
inline constexpr bool is_object_v = __is_object(_T);

#else

// clang-format off
template<class _T>
inline constexpr bool is_object_v
  = is_null_pointer_v<_T>
    || is_integral_v<_T>
    || is_floating_point_v<_T>
    || is_enum_v<_T>
    || is_pointer_v<_T>
    || is_member_object_pointer_v<_T>
    || is_member_function_pointer_v<_T>
    || is_array_v<_T>
    || is_union_v<_T>
    || is_class_v<_T>;
// clang-format on

template<class _T>
struct is_object : bool_constant<is_object_v<_T>> {};

#endif  // endregion

// region is_scalar
#if __LIGHTCXX_USE_BUILTIN(__is_scalar)

template<class _T>
struct is_scalar : bool_constant<__is_scalar(_T)> {};

template<class _T>
inline constexpr bool is_scalar_v = __is_scalar(_T);

#else

// clang-format off
template<class _T>
inline constexpr bool is_scalar_v
  = is_null_pointer_v<_T>
    || is_integral_v<_T>
    || is_floating_point_v<_T>
    || is_enum_v<_T>
    || is_pointer_v<_T>
    || is_member_object_pointer_v<_T>
    || is_member_function_pointer_v<_T>;
// clang-format on

template<class _T>
struct is_scalar : bool_constant<is_scalar_v<_T>> {};

#endif  // endregion

// region is_compound
#if __LIGHTCXX_USE_BUILTIN(__is_compound)

template<class _T>
struct is_compound : bool_constant<__is_compound(_T)> {};

template<class _T>
inline constexpr bool is_compound_v = __is_compound(_T);

#else

template<class _T>
struct is_compound : bool_constant<!is_fundamental_v<_T>> {};

template<class _T>
inline constexpr bool is_compound_v = !is_fundamental_v<_T>;

#endif  // endregion

// region is_member_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_member_pointer)

template<class _T>
struct is_member_pointer : bool_constant<__is_member_pointer(_T)> {};

template<class _T>
inline constexpr bool is_member_pointer_v = __is_member_pointer(_T);

#else

template<class _T>
struct is_member_pointer
        : bool_constant<is_member_object_pointer_v<_T> || is_member_function_pointer_v<_T>> {};

template<class _T>
inline constexpr bool is_member_pointer_v
  = is_member_object_pointer_v<_T> || is_member_function_pointer_v<_T>;

#endif  // endregion

// endregion

// region [meta.unary.prop]

// region is_(const,volatile)

#if __LIGHTCXX_USE_BUILTIN(__is_const)

template<class _T>
struct is_const : bool_constant<__is_const(_T)> {};

template<class _T>
inline constexpr bool is_const_v = __is_const(_T);

#else

template<class _T>
struct is_const : false_type {};

template<class _T>
struct is_const<_T const> : true_type {};

template<class _T>
inline constexpr bool is_const_v = is_const<_T>::value;

#endif

#if __LIGHTCXX_USE_BUILTIN(__is_volatile)

template<class _T>
struct is_volatile : bool_constant<__is_volatile(_T)> {};

template<class _T>
inline constexpr bool is_volatile_v = __is_volatile(_T);

#else

template<class _T>
struct is_volatile : false_type {};

template<class _T>
struct is_volatile<_T volatile> : true_type {};

template<class _T>
inline constexpr bool is_volatile_v = is_volatile<_T>::value;

#endif

// endregion

// region is_standard_layout
#if __LIGHTCXX_USE_BUILTIN(__is_standard_layout)

template<class _T>
struct is_standard_layout : bool_constant<__is_standard_layout(_T)> {};

template<class _T>
inline constexpr bool is_standard_layout_v = __is_standard_layout(_T);

#else

template<class _T>
struct is_standard_layout : false_type {
    static_assert(_Light::_False<_T>, "std::is_standard_layout is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_standard_layout_v = is_standard_layout<_T>::value;

#endif  // endregion

// region is_empty
#if __LIGHTCXX_USE_BUILTIN(__is_empty)

template<class _T>
struct is_empty : bool_constant<__is_empty(_T)> {};

template<class _T>
inline constexpr bool is_empty_v = __is_empty(_T);

#else

template<class _T>
struct is_empty : false_type {
    static_assert(_Light::_False<_T>, "std::is_empty is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_empty_v = is_empty<_T>::value;

#endif  // endregion

// region is_polymorphic
#if __LIGHTCXX_USE_BUILTIN(__is_polymorphic)

template<class _T>
struct is_polymorphic : bool_constant<__is_polymorphic(_T)> {};

template<class _T>
inline constexpr bool is_polymorphic_v = __is_polymorphic(_T);

#else

// clang-format off
template<class _T>
inline constexpr bool is_polymorphic_v = requires {
    { dynamic_cast<const volatile void*>(declval<_T*>()) };
};

template<class _T>
struct is_polymorphic: bool_constant<requires {
    { dynamic_cast<const volatile void*>(declval<_T*>()) };
}> {};
// clang-format on

#endif  // endregion

// region is_abstract
#if __LIGHTCXX_USE_BUILTIN(__is_abstract)

template<class _T>
struct is_abstract : bool_constant<__is_abstract(_T)> {};

template<class _T>
inline constexpr bool is_abstract_v = __is_abstract(_T);

#else

template<class _T>
struct is_abstract : false_type {
    static_assert(_Light::_False<_T>, "std::is_abstract is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_abstract_v = is_abstract<_T>::value;

#endif  // endregion

// region is_final
#if __LIGHTCXX_USE_BUILTIN(__is_final)

template<class _T>
struct is_final : bool_constant<__is_final(_T)> {};

template<class _T>
inline constexpr bool is_final_v = __is_final(_T);

#else

template<class _T>
struct is_final : false_type {
    static_assert(_Light::_False<_T>, "std::is_final is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_final_v = is_final<_T>::value;

#endif  // endregion

// region is_aggregate
#if __LIGHTCXX_USE_BUILTIN(__is_aggregate)

template<class _T>
struct is_aggregate : bool_constant<__is_aggregate(_T)> {};

template<class _T>
inline constexpr bool is_aggregate_v = __is_aggregate(_T);

#else

template<class _T>
struct is_aggregate : false_type {
    static_assert(_Light::_False<_T>, "std::is_aggregate is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_aggregate_v = is_aggregate<_T>::value;

#endif  // endregion

// region is_(signed,unsigned)
#if __LIGHTCXX_USE_BUILTIN(__is_signed)

// It seems like Clang's implementation of the trait does not check if the type is arithmetic,
// since it returns true for some types of enums.
template<class _T>
struct is_signed : bool_constant<__is_signed(_T) && is_arithmetic_v<_T>> {};

template<class _T>
inline constexpr bool is_signed_v = __is_signed(_T) && is_arithmetic_v<_T>;

#else

template<class _T>
struct is_signed : false_type {};

// clang-format off
template<class _T> requires is_arithmetic_v<_T>
struct is_signed<_T> : bool_constant<_T(-1) < _T(0)> {};
// clang-format on

template<class _T>
inline constexpr bool is_signed_v = false;

// clang-format off
template<class _T> requires is_arithmetic_v<_T>
inline constexpr bool is_signed_v<_T> = (_T(-1) < _T(0));
// clang-format on

#endif

#if __LIGHTCXX_USE_BUILTIN(__is_unsigned)

template<class _T>
struct is_unsigned : bool_constant<__is_unsigned(_T) && is_arithmetic_v<_T>> {};

template<class _T>
inline constexpr bool is_unsigned_v = __is_unsigned(_T) && is_arithmetic_v<_T>;

#else

template<class _T>
struct is_unsigned : false_type {};

// clang-format off
template<class _T> requires is_arithmetic_v<_T>
struct is_unsigned<_T> : bool_constant<_T(0) < _T(-1)> {};
// clang-format on

template<class _T>
inline constexpr bool is_unsigned_v = false;

// clang-format off
template<class _T> requires is_arithmetic_v<_T>
inline constexpr bool is_unsigned_v<_T> = (_T(0) < _T(-1));
// clang-format on

#endif

// endregion

// region is_(bounded,unbounded)_array

template<class _T>
struct is_bounded_array : false_type {};

template<class _T, size_t _N>
struct is_bounded_array<_T[_N]> : true_type {};

template<class _T>
inline constexpr bool is_bounded_array_v = false;

template<class _T, size_t _N>
inline constexpr bool is_bounded_array_v<_T[_N]> = true;

template<class _T>
struct is_unbounded_array : false_type {};

template<class _T>
struct is_unbounded_array<_T[]> : true_type {};

template<class _T>
inline constexpr bool is_unbounded_array_v = false;

template<class _T>
inline constexpr bool is_unbounded_array_v<_T[]> = true;

// endregion

// region is_(constructible,default_constructible,copy_constructible,move_constructible)

#if __LIGHTCXX_USE_BUILTIN(__is_constructible)

template<class _T, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_T, _Args...)> {};

template<class _T, class... _Args>
inline constexpr bool is_constructible_v = __is_constructible(_T, _Args...);

#else

// clang-format off

template<class _T, class... _Args>
inline constexpr bool is_constructible_v = requires {
    { new _T(declval<_Args>()...) } -> same_as<typename add_pointer<_T>::type>;
};

template<class _T, class _From>
inline constexpr bool is_constructible_v<_T&, _From> = requires {
    { static_cast<_T&>(declval<_From>()) };
};

template<class _T, class _From>
inline constexpr bool is_constructible_v<_T&&, _From> = requires {
    { static_cast<_T&&>(declval<_From>()) };
};

template<class _T, class _From>
inline constexpr bool is_constructible_v<_T&&, _From&> = is_function_v<_T> &&
  is_same_v<typename remove_cv<_T>::type, typename remove_cv<_From>::type>;

template<class _T, size_t _N>
inline constexpr bool is_constructible_v<_T[_N]> = is_constructible_v<_T>;

template<class _T, class... _Args>
struct is_constructible : bool_constant<is_constructible_v<_T, _Args...>> {};

// clang-format on

#endif

template<class _T>
struct is_default_constructible : bool_constant<is_constructible_v<_T>> {};

template<class _T>
inline constexpr bool is_default_constructible_v = is_constructible_v<_T>;

template<class _T>
struct is_copy_constructible
        : bool_constant<is_constructible_v<_T, typename add_lvalue_reference<const _T>::type>> {};

template<class _T>
inline constexpr bool is_copy_constructible_v
  = is_constructible_v<_T, typename add_lvalue_reference<const _T>::type>;

template<class _T>
struct is_move_constructible
        : bool_constant<is_constructible_v<_T, typename add_rvalue_reference<_T>::type>> {};

template<class _T>
inline constexpr bool is_move_constructible_v
  = is_constructible_v<_T, typename add_rvalue_reference<_T>::type>;

// endregion

// region is_(assignable,copy_assignable,move_assignable)

#if __LIGHTCXX_USE_BUILTIN(__is_assignable)

template<class _T, class _U>
struct is_assignable : bool_constant<__is_assignable(_T, _U)> {};

template<class _T, class _U>
inline constexpr bool is_assignable_v = __is_assignable(_T, _U);

#else

// clang-format off
template<class _T, class _U>
struct is_assignable : bool_constant<requires { { declval<_T>() = declval<_U>() }; }> {};

template<class _T, class _U>
inline constexpr bool is_assignable_v = requires { { declval<_T>() = declval<_U>() }; };
    // clang-format on

#endif

template<class _T>
struct is_copy_assignable
        : bool_constant<is_assignable_v<typename add_lvalue_reference<_T>::type,
                                        typename add_lvalue_reference<const _T>::type>> {};

template<class _T>
inline constexpr bool is_copy_assignable_v
  = is_assignable_v<typename add_lvalue_reference<_T>::type,
                    typename add_lvalue_reference<const _T>::type>;

template<class _T>
struct is_move_assignable
        : bool_constant<is_assignable_v<typename add_lvalue_reference<_T>::type,
                                        typename add_rvalue_reference<_T>::type>> {};

template<class _T>
inline constexpr bool is_move_assignable_v
  = is_assignable_v<typename add_lvalue_reference<_T>::type,
                    typename add_rvalue_reference<_T>::type>;

// endregion

// region is_destructible
#if __LIGHTCXX_USE_BUILTIN(__is_destructible)
template<class _T>
struct is_destructible : bool_constant<__is_destructible(_T)> {};

template<class _T>
inline constexpr bool is_destructible_v = __is_destructible(_T);
#else
// clang-format off
template<class _T>
inline constexpr bool is_destructible_v = requires {
    { declval<_T&>().~_T() };
};

template<class _T>
inline constexpr bool is_destructible_v<_T&> = true;

template<class _T>
inline constexpr bool is_destructible_v<_T&&> = true;

template<class _T>
inline constexpr bool is_destructible_v<_T[]> = is_destructible_v<_T>;

template<class _T, size_t _N>
inline constexpr bool is_destructible_v<_T[_N]> = is_destructible_v<_T>;
// clang-format on

template<class _T>
struct is_destructible : bool_constant<is_destructible_v<_T>> {};
#endif  // endregion

// region is_trivially_(constructible,default_constructible,copy_constructible,move_constructible)
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)
template<class _T, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_T, _Args...)> {};

template<class _T, class... _Args>
inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_T, _Args...);
#else
template<class _T, class...>
struct is_trivially_constructible : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_constructible is not supported on this compiler.");
};

template<class _T, class... _Args>
inline constexpr bool is_trivially_constructible_v
  = is_trivially_constructible<_T, _Args...>::value;
#endif

#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)
template<class _T>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_T)> {};

template<class _T>
inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_T);
#else
template<class _T>
struct is_trivially_default_constructible : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_default_constructible is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_default_constructible_v
  = is_trivially_default_constructible<_T>::value;
#endif

#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)
template<class _T>
struct is_trivially_copy_constructible : bool_constant<__is_trivially_constructible(
                                           _T, typename add_lvalue_reference<const _T>::type)> {};

template<class _T>
inline constexpr bool is_trivially_copy_constructible_v
  = __is_trivially_constructible(_T, typename add_lvalue_reference<const _T>::type);
#else
template<class _T>
struct is_trivially_copy_constructible : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_copy_constructible is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_copy_constructible_v
  = is_trivially_copy_constructible<_T>::value;
#endif

#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)
template<class _T>
struct is_trivially_move_constructible
        : bool_constant<__is_trivially_constructible(_T, typename add_rvalue_reference<_T>::type)> {
};

template<class _T>
inline constexpr bool is_trivially_move_constructible_v
  = __is_trivially_constructible(_T, typename add_rvalue_reference<_T>::type);
#else
template<class _T>
struct is_trivially_move_constructible : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_move_constructible is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_move_constructible_v
  = is_trivially_move_constructible<_T>::value;
#endif
// endregion

// region is_trivially_(assignable,copy_assignable,move_assignable)
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_assignable)
template<class _T, class _U>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_T, _U)> {};

template<class _T, class _U>
inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_T, _U);
#else
template<class _T, class>
struct is_trivially_assignable : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_assignable is not supported on this compiler.");
};

template<class _T, class _U>
inline constexpr bool is_trivially_assignable_v = is_trivially_assignable<_T, _U>::value;
#endif

#if __LIGHTCXX_USE_BUILTIN(__is_trivially_assignable)
template<class _T>
struct is_trivially_copy_assignable
        : bool_constant<__is_trivially_assignable(typename add_lvalue_reference<_T>::type,
                                                  typename add_lvalue_reference<const _T>::type)> {
};

template<class _T>
inline constexpr bool is_trivially_copy_assignable_v
  = __is_trivially_assignable(typename add_lvalue_reference<_T>::type,
                              typename add_lvalue_reference<const _T>::type);
#else
template<class _T>
struct is_trivially_copy_assignable : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_copy_assignable is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_T>::value;
#endif

#if __LIGHTCXX_USE_BUILTIN(__is_trivially_assignable)
template<class _T>
struct is_trivially_move_assignable
        : bool_constant<__is_trivially_assignable(typename add_lvalue_reference<_T>::type,
                                                  typename add_rvalue_reference<_T>::type)> {};

template<class _T>
inline constexpr bool is_trivially_move_assignable_v
  = __is_trivially_assignable(typename add_lvalue_reference<_T>::type,
                              typename add_rvalue_reference<_T>::type);
#else
template<class _T>
struct is_trivially_move_assignable : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_move_assignable is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_T>::value;
#endif
// endregion

// region is_trivially_destructible
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_destructible)
template<class _T>
struct is_trivially_destructible : false_type {};

// clang-format off
template<class _T> requires is_destructible_v<_T>
struct is_trivially_destructible<_T> : bool_constant<__is_trivially_destructible(_T)> {};
// clang-format on

template<class _T>
inline constexpr bool is_trivially_destructible_v = false;

// clang-format off
template<class _T> requires is_destructible_v<_T>
inline constexpr bool is_trivially_destructible_v<_T> = __is_trivially_destructible(_T);
// clang-format on
#else
template<class _T>
struct is_trivially_destructible : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_destructible is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<_T>::value;
#endif  // endregion

// region is_trivially_copyable
// TODO: Investigate further about Clang's __is_trivially_copyable builtin, but at first sight it
//  doesn't seem fully standard compliant (says a class with all copy/move constructors &
//  assignment operators deleted is trivially copyable, which contradicts [class.prop] paragraph
//  1.1).

#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)                                           \
  && __LIGHTCXX_USE_BUILTIN(__is_trivially_assignable)                                             \
  && __LIGHTCXX_USE_BUILTIN(__is_trivially_destructible) && __LIGHTCXX_USE_BUILTIN(__is_class)     \
  && __LIGHTCXX_USE_BUILTIN(__is_enum)

template<class _T>
constexpr bool is_trivially_copyable_v = []() {
    using _U =
      typename remove_cv<typename remove_all_extents<typename remove_cv<_T>::type>::type>::type;
    return is_scalar_v<_U>
      || (is_class_v<_U>
         // class.prop # 1.1
         && (is_copy_constructible_v<_U>
             || is_copy_assignable_v<_U>
             || is_move_constructible_v<_U>
             || is_move_assignable_v<_U>)
         // class.prop # 1.2
         && (!is_copy_constructible_v<_U> || is_trivially_copy_constructible_v<_U>)
         && (!is_copy_assignable_v<_U> || is_trivially_copy_assignable_v<_U>)
         && (!is_move_constructible_v<_U> || is_trivially_move_constructible_v<_U>)
         && (!is_move_assignable_v<_U> || is_trivially_move_assignable_v<_U>)
         //  class.prop # 1.3
         && is_trivially_destructible_v<_U>);
}();

template<class _T>
struct is_trivially_copyable : bool_constant<is_trivially_copyable_v<_T>> {};

#else

template<class _T>
struct is_trivially_copyable : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_copyable is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<_T>::value;

#endif  // endregion

// region is_trivial
// TODO: Investigate further about Clang's __is_trivial builtin, but at first sight it doesn't seem
//  fully standard compliant (says a class with all copy/move constructors &
//  assignment operators deleted is trivial, which contradicts [class.prop] paragraph 1.1).

#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)                                           \
  && __LIGHTCXX_USE_BUILTIN(__is_trivially_assignable)                                             \
  && __LIGHTCXX_USE_BUILTIN(__is_trivially_destructible) && __LIGHTCXX_USE_BUILTIN(__is_class)     \
  && __LIGHTCXX_USE_BUILTIN(__is_enum)

template<class _T>
struct is_trivial
        : bool_constant<is_trivially_copyable_v<_T> && is_trivially_default_constructible_v<_T>> {};

template<class _T>
inline constexpr bool is_trivial_v
  = is_trivially_copyable_v<_T>&& is_trivially_default_constructible_v<_T>;

#else

template<class _T>
struct is_trivial : false_type {
    static_assert(_Light::_False<_T>, "std::is_trivial is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivial_v = is_trivial<_T>::value;

#endif  // endregion

// region is_nothrow_(constructible,default_constructible,copy_constructible,move_constructible)
#if __LIGHTCXX_USE_BUILTIN(__is_nothrow_constructible)
template<class _T, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_T, _Args...)> {};

template<class _T, class... _Args>
constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_T, _Args...);
#else
// clang-format off
template<class _T, class... _Args>
inline constexpr bool is_nothrow_constructible_v = requires {
    { new _T(declval<_Args>()...) } -> same_as<typename add_pointer<_T>::type>;
    { _T(declval<_Args>()...) } noexcept;
};

template<class _T, class _From>
inline constexpr bool is_nothrow_constructible_v<_T&, _From> = requires {
    { static_cast<_T&>(declval<_From>()) } noexcept;
};

template<class _T, class _From>
inline constexpr bool is_nothrow_constructible_v<_T&&, _From> = requires {
    { static_cast<_T&&>(declval<_From>()) } noexcept;
};

template<class _T, class _From>
inline constexpr bool is_nothrow_constructible_v<_T&&, _From&> = is_function_v<_T> &&
  is_same_v<typename remove_cv<_T>::type, typename remove_cv<_From>::type>;

template<class _T, size_t _N>
inline constexpr bool is_nothrow_constructible_v<_T[_N]> = is_nothrow_constructible_v<_T>;

template<class _T, class... _Args>
struct is_nothrow_constructible : bool_constant<is_nothrow_constructible_v<_T, _Args...>> {};
// clang-format on
#endif

template<class _T>
struct is_nothrow_default_constructible : bool_constant<is_nothrow_constructible_v<_T>> {};

template<class _T>
inline constexpr bool is_nothrow_default_constructible_v = is_nothrow_constructible_v<_T>;

template<class _T>
struct is_nothrow_copy_constructible
        : bool_constant<
            is_nothrow_constructible_v<_T, typename add_lvalue_reference<const _T>::type>> {};

template<class _T>
inline constexpr bool is_nothrow_copy_constructible_v
  = is_nothrow_constructible_v<_T, typename add_lvalue_reference<const _T>::type>;

template<class _T>
struct is_nothrow_move_constructible
        : bool_constant<is_nothrow_constructible_v<_T, typename add_rvalue_reference<_T>::type>> {};

template<class _T>
inline constexpr bool is_nothrow_move_constructible_v
  = is_nothrow_constructible_v<_T, typename add_rvalue_reference<_T>::type>;

// endregion

// region is_nothrow_(assignable,copy_assignable,move_assignable)
#if __LIGHTCXX_USE_BUILTIN(__is_nothrow_assignable)

template<class _T, class _U>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_T, _U)> {};

template<class _T, class _U>
inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_T, _U);

#else

// clang-format off
template<class _T, class _U>
struct is_nothrow_assignable : bool_constant<requires {
    { declval<_T>() = declval<_U>() } noexcept;
}> {};

template<class _T, class _U>
inline constexpr bool is_nothrow_assignable_v = requires {
    { declval<_T>() = declval<_U>() } noexcept;
};
    // clang-format on

#endif

template<class _T>
struct is_nothrow_copy_assignable
        : bool_constant<is_nothrow_assignable_v<typename add_lvalue_reference<_T>::type,
                                                typename add_lvalue_reference<const _T>::type>> {};

template<class _T>
inline constexpr bool is_nothrow_copy_assignable_v
  = is_nothrow_assignable_v<typename add_lvalue_reference<_T>::type,
                            typename add_lvalue_reference<const _T>::type>;

template<class _T>
struct is_nothrow_move_assignable
        : bool_constant<is_nothrow_assignable_v<typename add_lvalue_reference<_T>::type,
                                                typename add_rvalue_reference<_T>::type>> {};

template<class _T>
inline constexpr bool is_nothrow_move_assignable_v
  = is_nothrow_assignable_v<typename add_lvalue_reference<_T>::type,
                            typename add_rvalue_reference<_T>::type>;
// endregion

// region is_nothrow_destructible

// clang-format off
template<class _T>
inline constexpr bool is_nothrow_destructible_v = requires {
    { declval<_T&>().~_T() } noexcept;
};

template<class _T>
inline constexpr bool is_nothrow_destructible_v<_T&> = true;

template<class _T>
inline constexpr bool is_nothrow_destructible_v<_T&&> = true;

template<class _T>
inline constexpr bool is_nothrow_destructible_v<_T[]> = is_nothrow_destructible_v<_T>;

template<class _T, size_t _N>
inline constexpr bool is_nothrow_destructible_v<_T[_N]> = is_nothrow_destructible_v<_T>;
// clang-format on

template<class _T>
struct is_nothrow_destructible : bool_constant<is_nothrow_destructible_v<_T>> {};

// endregion

// region swap, is_swappable_with, is_swappable, is_nothrow_swappable_with, is_nothrow_swappable
// clang-format off

template<class _T> requires is_move_constructible_v<_T> && is_move_assignable_v<_T>
constexpr void swap(_T& __a, _T& __b)
        noexcept(is_nothrow_move_constructible_v<_T> && is_nothrow_move_assignable_v<_T>) {
    _T __tmp{move(__a)};
    __a = move(__b);
    __b = move(__tmp);
}

template<class _T, size_t _N> requires is_swappable<_T>::value
constexpr void swap(_T (&__a)[_N], _T (&__b)[_N]) noexcept(is_nothrow_swappable<_T>::value) {
    for (_T *__p_a = __a, *__p_b = __b; __p_a < __a + _N; __p_a++, __p_b++) {
        _T __tmp{move(*__p_a)};
        *__p_a = move(*__p_b);
        __p_b = move(__tmp);
    }
}

template<class _T, class _U>
inline constexpr bool is_swappable_with_v = requires {
    { swap(declval<_T>(), declval<_U>()) };
    { swap(declval<_U>(), declval<_T>()) };
};

template<class _T, class _U>
struct is_swappable_with : bool_constant<is_swappable_with_v<_T, _U>> {};

template<class _T>
inline constexpr bool is_swappable_v = false;

template<_Light::_Referenceable _T>
inline constexpr bool is_swappable_v<_T> = is_swappable_with_v<_T&, _T&>;

template<class _T>
struct is_swappable : bool_constant<is_swappable_v<_T>> {};

template<class _T, class _U>
inline constexpr bool is_nothrow_swappable_with_v = requires {
    { swap(declval<_T>(), declval<_U>()) } noexcept;
    { swap(declval<_U>(), declval<_T>()) } noexcept;
};

template<class _T, class _U>
struct is_nothrow_swappable_with : bool_constant<is_nothrow_swappable_with_v<_T, _U>> {};

template<class _T>
inline constexpr bool is_nothrow_swappable_v = false;

template<_Light::_Referenceable _T>
inline constexpr bool is_nothrow_swappable_v<_T> = is_nothrow_swappable_with_v<_T&, _T&>;

template<class _T>
struct is_nothrow_swappable : bool_constant<is_nothrow_swappable_v<_T>> {};

// clang-format on
// endregion

// region has_virtual_destructor
#if __LIGHTCXX_USE_BUILTIN(__has_virtual_destructor)

template<class _T>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_T)> {};

template<class _T>
inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_T);

#else

template<class _T>
struct has_virtual_destructor : false_type {
    static_assert(_Light::_False<_T>,
                  "std::has_virtual_destructor is not supported on this compiler.");
};

template<class _T>
inline constexpr bool has_virtual_destructor_v = has_virtual_destructor<_T>::value;

#endif  // endregion

// region has_unique_object_representations
#if __LIGHTCXX_USE_BUILTIN(__has_unique_object_representations)

template<class _T>
struct has_unique_object_representations : bool_constant<__has_unique_object_representations(_T)> {
};

template<class _T>
inline constexpr bool has_unique_object_representations_v = __has_unique_object_representations(_T);

#else

template<class _T>
struct has_unique_object_representations : false_type {
    static_assert(_Light::_False<_T>,
                  "std::has_unique_object_representations is not supported on this compiler.");
};

template<class _T>
inline constexpr bool has_unique_object_representations_v
  = has_unique_object_representations<_T>::value;

#endif  // endregion

// endregion

// region [meta.unary.prop.query]

// region alignment_of
template<class _T>
struct alignment_of : integral_constant<size_t, alignof(_T)> {};

template<class _T>
inline constexpr size_t alignment_of_v = alignof(_T);
// endregion

// region rank
template<class _T>
struct rank : integral_constant<size_t, 0> {};

template<class _T>
struct rank<_T[]> : integral_constant<size_t, rank<_T>::value + 1> {};

template<class _T, size_t _N>
struct rank<_T[_N]> : integral_constant<size_t, rank<_T>::value + 1> {};

template<class _T>
inline constexpr auto rank_v = rank<_T>::value;
// endregion

// region extent
#if __LIGHTCXX_USE_BUILTIN(__array_extent)
template<class _T, unsigned _I = 0>
struct extent : integral_constant<size_t, __array_extent(_T, _I)> {};

template<class _T, unsigned _I = 0>
inline constexpr auto extent_v = __array_extent(_T, _I);
#else
template<class _T, unsigned _I = 0>
struct extent : integral_constant<size_t, 0> {};

template<class _T>
struct extent<_T[], 0> : integral_constant<size_t, 0> {};

template<class _T, size_t _N>
struct extent<_T[_N], 0> : integral_constant<size_t, _N> {};

template<class _T, unsigned _I>
struct extent<_T[], _I> : extent<_T, _I - 1> {};

template<class _T, size_t _N, unsigned _I>
struct extent<_T[_N], _I> : extent<_T, _I - 1> {};

template<class _T, unsigned _I = 0>
inline constexpr auto extent_v = extent<_T, _I>::value;
#endif
// endregion

// endregion

// region [meta.rel]

// is_same defined above

// region is_base_of
#if __LIGHTCXX_USE_BUILTIN(__is_base_of)                                                           \
  || (!defined(__LIGHTCXX_TESTING_DISALLOW_IS_BASE_OF_BUILTIN)                                     \
      && (defined(__is_base_of) || (defined(__has_builtin) && __has_builtin(__is_base_of))))
template<class _B, class _D>
struct is_base_of : bool_constant<__is_base_of(_B, _D)> {};

template<class _B, class _D>
inline constexpr bool is_base_of_v = __is_base_of(_B, _D);
#else
namespace _Light {

template<class _B>
true_type _ConvertPtr(const volatile _B*);

template<class _B>
false_type _ConvertPtr(const volatile void*);

template<class _B, class _D>
auto _IsBaseOf(double) -> true_type;

template<class _B, class _D>
auto _IsBaseOf(int) -> decltype(_ConvertPtr<_B>(declval<_D*>()));

}  // namespace _Light

template<class _B, class _D>
inline constexpr bool is_base_of_v
  = is_class<_B>::value&& is_class<_D>::value&& decltype(_Light::_IsBaseOf<_B, _D>(0))::value;

template<class _B, class _D>
struct is_base_of : bool_constant<is_base_of_v<_B, _D>> {};
#endif
// endregion

// region is_convertible
#if __LIGHTCXX_USE_BUILTIN(__is_convertible)
template<class _From, class _To>
struct is_convertible : bool_constant<__is_convertible(_From, _To)> {};

template<class _From, class _To>
inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
#else
namespace _Light {

template<class _T>
decltype(void(declval<_T (*)()>()), true_type{}) _TryReturn(int);

template<class _T>
false_type _TryReturn(double);

template<class _From, class _To>
decltype(void(declval<void (&)(_To)>()(declval<_From>())), true_type{}) _IsConvertible(int);

template<class _From, class _To>
false_type _IsConvertible(double);

}  // namespace _Light

template<class _From, class _To>
inline constexpr bool is_convertible_v = (decltype(_Light::_TryReturn<_To>(0))::value
                                          && decltype(_Light::_IsConvertible<_From, _To>(0))::value)
                                         || (is_void_v<_From> && is_void_v<_To>);

template<class _From, class _To>
struct is_convertible : bool_constant<is_convertible_v<_From, _To>> {};
#endif
// endregion

// region is_nothrow_convertible
template<class _From, class _To>
inline constexpr bool is_nothrow_convertible_v = (is_void_v<_From> && is_void_v<_To>) || requires {
    {static_cast<_To (*)()>(nullptr)};
    { declval<void (&)(_To) noexcept>()(declval<_From>()) }
    noexcept;
};

template<class _From, class _To>
struct is_nothrow_convertible : bool_constant<is_nothrow_convertible_v<_From, _To>> {};
// endregion

// region is_layout_compatible
// TODO: Implement is_layout_compatible
// endregion

// region is_pointer_interconvertible_base_of
// TODO: Implement is_pointer_interconvertible_base_of
// endregion

// region is_invocable
namespace _Light {
template<class _T>
constexpr bool _IsRefWrapper = false;
template<class _T>
constexpr bool _IsRefWrapper<reference_wrapper<_T>> = true;

template<class _T, class _Mem, class _A>
constexpr bool _IsBaseMemPtr
  = is_object_v<
      _Mem> && !is_base_of_v<_T, typename decay<_A>::type> && !_IsRefWrapper<typename decay<_A>::type>;
}  // namespace _Light

template<class _F, class... _Args>
inline constexpr bool is_invocable_v = requires {
    {declval<_F>()(declval<_Args>()...)};
};

template<class _T, class _Mem, class _A, class... _Args>
requires is_function_v<_Mem> && is_base_of_v<_T, typename decay<_A>::type>
inline constexpr bool is_invocable_v<_Mem _T::*, _A, _Args...> = requires(_Mem _T::*__f) {
    {(declval<_A>().*__f)(declval<_Args>()...)};
};

template<class _T, class _Mem, class _A, class... _Args>
requires is_function_v<_Mem> && _Light::_IsRefWrapper<typename decay<_A>::type>
inline constexpr bool is_invocable_v<_Mem _T::*, _A, _Args...> = requires(_Mem _T::*__f) {
    {(declval<_A>().get().*__f)(declval<_Args>()...)};
};

template<class _T, class _Mem, class _A>
requires _Light::_IsBaseMemPtr<_T, _Mem, _A>
inline constexpr bool is_invocable_v<_Mem _T::*, _A> = requires(_Mem _T::*__f) {
    {(*declval<_A>()).*__f};
};

template<class _T, class _Mem, class _A>
requires is_object_v<_Mem> && is_base_of_v<_T, typename decay<_A>::type>
inline constexpr bool is_invocable_v<_Mem _T::*, _A> = requires(_Mem _T::*__f) {
    {declval<_A>().*__f};
};

template<class _T, class _Mem, class _A>
requires is_object_v<_Mem> && _Light::_IsRefWrapper<typename decay<_A>::type>
inline constexpr bool is_invocable_v<_Mem _T::*, _A> = requires(_Mem _T::*__f) {
    {declval<_A>.get().*__f};
};

template<class _F, class... _Args>
struct is_invocable : bool_constant<is_invocable_v<_F, _Args...>> {};
// endregion

// region is_invocable_r
namespace _Light {
template<class _From, class _To>
concept _VoidOrConvertibleTo = is_void_v<_To> || is_convertible_v<_From, _To>;
}  // namespace _Light

template<class _R, class _F, class... _Args>
inline constexpr bool is_invocable_r_v = requires {
    { declval<_F>()(declval<_Args>()...) } -> _Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _T, class _Mem, class _A, class... _Args>
requires is_function_v<_Mem> && is_base_of_v<_T, typename decay<_A>::type>
inline constexpr bool is_invocable_r_v<_R, _Mem _T::*, _A, _Args...> = requires(_Mem _T::*__f) {
    { (declval<_A>().*__f)(declval<_Args>()...) } -> _Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _T, class _Mem, class _A, class... _Args>
requires is_function_v<_Mem> && _Light::_IsRefWrapper<typename decay<_A>::type>
inline constexpr bool is_invocable_r_v<_R, _Mem _T::*, _A, _Args...> = requires(_Mem _T::*__f) {
    { (declval<_A>().get().*__f)(declval<_Args>()...) } -> _Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _T, class _Mem, class _A>
requires _Light::_IsBaseMemPtr<_T, _Mem, _A>
inline constexpr bool is_invocable_r_v<_R, _Mem _T::*, _A> = requires(_Mem _T::*__f) {
    { (*declval<_A>()).*__f } -> _Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _T, class _Mem, class _A>
requires is_object_v<_Mem> && is_base_of_v<_T, typename decay<_A>::type>
inline constexpr bool is_invocable_r_v<_R, _Mem _T::*, _A> = requires(_Mem _T::*__f) {
    { declval<_A>().*__f } -> _Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _T, class _Mem, class _A>
requires is_object_v<_Mem> && _Light::_IsRefWrapper<typename decay<_A>::type>
inline constexpr bool is_invocable_r_v<_R, _Mem _T::*, _A> = requires(_Mem _T::*__f) {
    { declval<_A>.get().*__f } -> _Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _F, class... _Args>
struct is_invocable_r : bool_constant<is_invocable_r_v<_R, _F, _Args...>> {};
// endregion

// region is_nothrow_invocable
template<class _F, class... _Args>
inline constexpr bool is_nothrow_invocable_v = requires {
    { declval<_F>()(declval<_Args>()...) }
    noexcept;
};

template<class _T, class _Mem, class _A, class... _Args>
requires is_function_v<_Mem> && is_base_of_v<_T, typename decay<_A>::type>
inline constexpr bool is_nothrow_invocable_v<_Mem _T::*, _A, _Args...> = requires(_Mem _T::*__f) {
    { (declval<_A>().*__f)(declval<_Args>()...) }
    noexcept;
};

template<class _T, class _Mem, class _A, class... _Args>
requires is_function_v<_Mem> && _Light::_IsRefWrapper<typename decay<_A>::type>
inline constexpr bool is_nothrow_invocable_v<_Mem _T::*, _A, _Args...> = requires(_Mem _T::*__f) {
    { (declval<_A>().get().*__f)(declval<_Args>()...) }
    noexcept;
};

template<class _T, class _Mem, class _A>
requires _Light::_IsBaseMemPtr<_T, _Mem, _A>
inline constexpr bool is_nothrow_invocable_v<_Mem _T::*, _A> = requires(_Mem _T::*__f) {
    { (*declval<_A>()).*__f }
    noexcept;
};

template<class _T, class _Mem, class _A>
requires is_object_v<_Mem> && is_base_of_v<_T, typename decay<_A>::type>
inline constexpr bool is_nothrow_invocable_v<_Mem _T::*, _A> = requires(_Mem _T::*__f) {
    { declval<_A>().*__f }
    noexcept;
};

template<class _T, class _Mem, class _A>
requires is_object_v<_Mem> && _Light::_IsRefWrapper<typename decay<_A>::type>
inline constexpr bool is_nothrow_invocable_v<_Mem _T::*, _A> = requires(_Mem _T::*__f) {
    { declval<_A>.get().*__f }
    noexcept;
};

template<class _F, class... _Args>
struct is_nothrow_invocable : bool_constant<is_nothrow_invocable_v<_F, _Args...>> {};
// endregion

// region is_nothrow_invocable_r
template<class _R, class _F, class... _Args>
inline constexpr bool is_nothrow_invocable_r_v = requires {
    { declval<_F>()(declval<_Args>()...) }
    noexcept->_Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _T, class _Mem, class _A, class... _Args>
requires is_function_v<_Mem> && is_base_of_v<_T, typename decay<_A>::type>
inline constexpr bool is_nothrow_invocable_r_v<_R, _Mem _T::*, _A, _Args...> = requires(
  _Mem _T::*__f) {
    { (declval<_A>().*__f)(declval<_Args>()...) }
    noexcept->_Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _T, class _Mem, class _A, class... _Args>
requires is_function_v<_Mem> && _Light::_IsRefWrapper<typename decay<_A>::type>
inline constexpr bool is_nothrow_invocable_r_v<_R, _Mem _T::*, _A, _Args...> = requires(
  _Mem _T::*__f) {
    { (declval<_A>().get().*__f)(declval<_Args>()...) }
    noexcept->_Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _T, class _Mem, class _A>
requires _Light::_IsBaseMemPtr<_T, _Mem, _A>
inline constexpr bool is_nothrow_invocable_r_v<_R, _Mem _T::*, _A> = requires(_Mem _T::*__f) {
    { (*declval<_A>()).*__f }
    noexcept->_Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _T, class _Mem, class _A>
requires is_object_v<_Mem> && is_base_of_v<_T, typename decay<_A>::type>
inline constexpr bool is_nothrow_invocable_r_v<_R, _Mem _T::*, _A> = requires(_Mem _T::*__f) {
    { declval<_A>().*__f }
    noexcept->_Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _T, class _Mem, class _A>
requires is_object_v<_Mem> && _Light::_IsRefWrapper<typename decay<_A>::type>
inline constexpr bool is_nothrow_invocable_r_v<_R, _Mem _T::*, _A> = requires(_Mem _T::*__f) {
    { declval<_A>.get().*__f }
    noexcept->_Light::_VoidOrConvertibleTo<_R>;
};

template<class _R, class _F, class... _Args>
struct is_nothrow_invocable_r : bool_constant<is_nothrow_invocable_r_v<_R, _F, _Args...>> {};
// endregion

// endregion

// region [meta.trans.cv]

// region remove_const
template<class _T>
struct remove_const {
    using type = _T;
};

template<class _T>
struct remove_const<const _T> {
    using type = _T;
};

template<class _T>
using remove_const_t = typename remove_const<_T>::type;
// endregion

// region remove_volatile
template<class _T>
struct remove_volatile {
    using type = _T;
};

template<class _T>
struct remove_volatile<volatile _T> {
    using type = _T;
};

template<class _T>
using remove_volatile_t = typename remove_volatile<_T>::type;
// endregion

// region remove_cv
template<class _T>
struct remove_cv {
    using type = _T;
};

template<class _T>
struct remove_cv<const _T> {
    using type = _T;
};

template<class _T>
struct remove_cv<volatile _T> {
    using type = _T;
};

template<class _T>
struct remove_cv<const volatile _T> {
    using type = _T;
};

template<class _T>
using remove_cv_t = typename remove_cv<_T>::type;
// endregion

// region add_const
template<class _T>
struct add_const {
    using type = const _T;
};

template<class _T>
using add_const_t = typename add_const<_T>::type;
// endregion

// region add_volatile
template<class _T>
struct add_volatile {
    using type = volatile _T;
};

template<class _T>
using add_volatile_t = typename add_volatile<_T>::type;
// endregion

// region add_cv
template<class _T>
struct add_cv {
    using type = const volatile _T;
};

template<class _T>
using add_cv_t = typename add_cv<_T>::type;
// endregion

// endregion

// region [meta.trans.ref]

// region remove_reference
template<class _T>
struct remove_reference {
    using type = _T;
};

template<class _T>
struct remove_reference<_T&> {
    using type = _T;
};

template<class _T>
struct remove_reference<_T&&> {
    using type = _T;
};

template<class _T>
using remove_reference_t = typename remove_reference<_T>::type;
// endregion

// region add_lvalue_reference
template<class _T>
struct add_lvalue_reference {
    using type = _T;
};

template<_Light::_Referenceable _T>
struct add_lvalue_reference<_T> {
    using type = remove_reference_t<_T>&;
};

template<class _T>
using add_lvalue_reference_t = typename add_lvalue_reference<_T>::type;
// endregion

// region add_rvalue_reference
template<class _T>
struct add_rvalue_reference {
    using type = _T;
};

template<_Light::_Referenceable _T>
struct add_rvalue_reference<_T> {
    using type = remove_reference_t<_T>&&;
};

template<class _T>
using add_rvalue_reference_t = typename add_rvalue_reference<_T>::type;
// endregion

// endregion

// region [meta.trans.sign]

// region make_signed
// TODO: Implement make_signed
// endregion

// region make_unsigned
// TODO: Implement make_unsigned
// endregion

// endregion

// region [meta.trans.arr]

// region remove_extent
template<class _T>
struct remove_extent {
    using type = _T;
};

template<class _T>
struct remove_extent<_T[]> {
    using type = _T;
};

template<class _T, size_t _N>
struct remove_extent<_T[_N]> {
    using type = _T;
};

template<class _T>
using remove_extent_t = typename remove_extent<_T>::type;
// endregion

// region remove_all_extents
template<class _T>
struct remove_all_extents {
    using type = _T;
};

template<class _T>
struct remove_all_extents<_T[]> {
    using type = typename remove_all_extents<_T>::type;
};

template<class _T, size_t _N>
struct remove_all_extents<_T[_N]> {
    using type = typename remove_all_extents<_T>::type;
};

template<class _T>
using remove_all_extents_t = typename remove_all_extents<_T>::type;
// endregion

// endregion

// region [meta.trans.ptr]

// region remove_pointer
// TODO: Implement remove_pointer
// endregion

// region add_pointer
template<class _T>
struct add_pointer {
    using type = _T;
};

template<class _T>
requires _Light::_Referenceable<_T> || is_void_v<_T>
struct add_pointer<_T> {
    using type = remove_reference_t<_T>*;
};

template<class _T>
using add_pointer_t = typename add_pointer<_T>::type;
// endregion

// endregion

// region [meta.trans.other]

// region type_identity
template<class _T>
struct type_identity {
    using type = _T;
};

template<class _T>
using type_identity_t = _T;
// endregion

// region aligned_storage
// TODO: Implement aligned_storage
// endregion

// region aligned_union
// TODO: Implement aligned_union
// endregion

// region remove_cvref
// TODO: Implement remove_cvref
// endregion

// region decay
template<class _T>
struct decay {
  private:
    using _U = remove_reference_t<_T>;

  public:
    using type = typename conditional<
      is_array_v<_U>, remove_extent_t<_U>*,
      typename conditional<is_function_v<_U>, add_pointer_t<_U>, remove_cv_t<_U>>::type>::type;
};

template<class _T>
using decay_t = typename decay<_T>::type;
// endregion

// region enable_if
// TODO: Implement enable_if
// endregion

// region conditional
template<bool _B, class _T, class _F>
struct conditional {
    using type = _T;
};

template<class _T, class _F>
struct conditional<false, _T, _F> {
    using type = _F;
};

template<bool _B, class _T, class _F>
using conditional_t = typename conditional<_B, _T, _F>::type;
// endregion

// region common_type
// TODO: Implement common_type
// endregion

// region basic_common_reference
// TODO: Implement basic_common_reference
// endregion

// region common_reference
// TODO: Implement common_reference
// endregion

// region underlying_type
// TODO: Implement underlying_type
// endregion

// region invoke_result
// TODO: Implement invoke_result
// endregion

// region unwrap_reference
// TODO: Implement unwrap_reference
// endregion

// region unwrap_ref_decay
// TODO: Implement unwrap_ref_decay
// endregion

// endregion

// region [meta.logical]

// region conjunction
// TODO: Implement conjunction
// endregion

// region disjunction
// TODO: Implement disjunction
// endregion

// region negation
// TODO: Implement negation
// endregion

// endregion

// region [meta.member]

// region is_pointer_interconvertible_with_class
// TODO: Implement is_pointer_interconvertible_with_class
// endregion

// region is_corresponding_member
// TODO: Implement is_corresponding_member
// endregion

// endregion

// region [meta.const.eval]

// region is_constant_evaluated
// TODO: Implement is_constant_evaluated
// endregion

// endregion

}  // namespace std

#undef __UNARY_TRAIT_TRUE_FOR_ALL_CV
#undef __LIGHTCXX_USE_BUILTIN

#endif

#ifndef __LIGHTCXX_GUARD_TYPE_TRAITS
#define __LIGHTCXX_GUARD_TYPE_TRAITS

#include <__lightcxx/__declval.h>

namespace std {

using size_t = decltype(sizeof(void*));
using nullptr_t = decltype(nullptr);

// region [meta.help]

template<class _T, _T _V>
struct integral_constant {
    static constexpr _T value = _V;

    using value_type = _T;

    using type = integral_constant<_T, _V>;

    constexpr operator value_type() const noexcept {
        return value;
    }

    constexpr value_type operator()() const noexcept {
        return value;
    }
};

template<bool _B>
using bool_constant = integral_constant<bool, _B>;

using true_type = bool_constant<true>;

using false_type = bool_constant<false>;

// endregion

// region std::is_same, std::same_as

template<class _T, class _U>
struct is_same : false_type {};

template<class _T>
struct is_same<_T, _T> : true_type {};

template<class _T, class _U>
inline constexpr bool is_same_v = false;

template<class _T>
inline constexpr bool is_same_v<_T, _T> = true;

template<class _T, class _U>
concept same_as = is_same_v<_T, _U>;

// endregion

// region implementation-details

namespace _Light {

template<class _T>
inline constexpr bool _False = false;

template<class _T>
using _NonSfinaeAddReference = _T&;

template<class _T>
concept _Referenceable = requires {
    typename _NonSfinaeAddReference<_T>;
};

}  // namespace _Light

#define __UNARY_TRAIT_TRUE_FOR_ALL_CV(_Trait, _T)                                                  \
    template<>                                                                                     \
    struct _Trait<_T> : ::std::true_type {};                                                       \
    template<>                                                                                     \
    struct _Trait<_T const> : ::std::true_type {};                                                 \
    template<>                                                                                     \
    struct _Trait<_T volatile> : ::std::true_type {};                                              \
    template<>                                                                                     \
    struct _Trait<_T const volatile> : ::std::true_type {}

#ifdef _LIGHTCXX_DONT_USE_BUILTINS
#define __LIGHTCXX_USE_BUILTIN(_B) 0
#else
#define __LIGHTCXX_USE_BUILTIN(_B) (defined(_B) || (defined(__has_builtin) && __has_builtin(_B)))
#endif

// endregion

// region [meta.unary.cat]

// region is_void
#if __LIGHTCXX_USE_BUILTIN(__is_void)

template<class _T>
struct is_void : bool_constant<__is_void(_T)> {};

template<class _T>
inline constexpr bool is_void_v = __is_void(_T);

#else

template<class _T>
struct is_void : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_void, void);

template<class _T>
inline constexpr bool is_void_v = is_void<_T>::value;

#endif  // endregion

// region is_null_pointer
template<class _T>
struct is_null_pointer : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_null_pointer, nullptr_t);

template<class _T>
inline constexpr bool is_null_pointer_v = is_null_pointer<_T>::value;
// endregion

// region is_integral
#if __LIGHTCXX_USE_BUILTIN(__is_integral)

template<class _T>
struct is_integral : bool_constant<__is_integral(_T)> {};

template<class _T>
inline constexpr bool is_integral_v = __is_integral(_T);

#else

template<class _T>
struct is_integral : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, bool);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, wchar_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char8_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char16_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, char32_t);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, signed char);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, short);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, long int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, long long int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned char);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned short int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned long int);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_integral, unsigned long long int);

template<class _T>
inline constexpr bool is_integral_v = is_integral<_T>::value;

#endif  // endregion

// region is_floating_point
#if __LIGHTCXX_USE_BUILTIN(__is_floating_point)

template<class _T>
struct is_floating_point : bool_constant<__is_floating_point(_T)> {};

template<class _T>
inline constexpr bool is_floating_point_v = __is_floating_point(_T);

#else

template<class _T>
struct is_floating_point : false_type {};

__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_floating_point, float);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_floating_point, double);
__UNARY_TRAIT_TRUE_FOR_ALL_CV(is_floating_point, long double);

template<class _T>
inline constexpr bool is_floating_point_v = is_floating_point<_T>::value;

#endif  // endregion

// region is_array
#if __LIGHTCXX_USE_BUILTIN(__is_array)

template<class _T>
struct is_array : bool_constant<__is_array(_T)> {};

template<class _T>
inline constexpr bool is_array_v = __is_array(_T);

#else

template<class _T>
struct is_array : false_type {};

template<class _T>
struct is_array<_T[]> : true_type {};

template<class _T, size_t _N>
struct is_array<_T[_N]> : true_type {};

template<class _T>
inline constexpr bool is_array_v = is_array<_T>::value;

#endif  // endregion

// region is_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_pointer)

template<class _T>
struct is_pointer : bool_constant<__is_pointer(_T)> {};

template<class _T>
inline constexpr bool is_pointer_v = __is_pointer(_T);

#else

template<class _T>
struct is_pointer : false_type {};

template<class _T>
struct is_pointer<_T*> : true_type {};

template<class _T>
struct is_pointer<_T* const> : true_type {};

template<class _T>
struct is_pointer<_T* volatile> : true_type {};

template<class _T>
struct is_pointer<_T* const volatile> : true_type {};

template<class _T>
inline constexpr bool is_pointer_v = is_pointer<_T>::value;

#endif  // endregion

// region is_lvalue_reference
#if __LIGHTCXX_USE_BUILTIN(__is_lvalue_reference)

template<class _T>
struct is_lvalue_reference : bool_constant<__is_lvalue_reference(_T)> {};

template<class _T>
inline constexpr bool is_lvalue_reference_v = __is_lvalue_reference(_T);

#else

template<class _T>
struct is_lvalue_reference : false_type {};

template<class _T>
struct is_lvalue_reference<_T&> : true_type {};

template<class _T>
inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<_T>::value;

#endif  // endregion

// region is_rvalue_reference
#if __LIGHTCXX_USE_BUILTIN(__is_rvalue_reference)

template<class _T>
struct is_rvalue_reference : bool_constant<__is_rvalue_reference(_T)> {};

template<class _T>
inline constexpr bool is_rvalue_reference_v = __is_rvalue_reference(_T);

#else

template<class _T>
struct is_rvalue_reference : false_type {};

template<class _T>
struct is_rvalue_reference<_T&&> : true_type {};

template<class _T>
inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<_T>::value;

#endif  // endregion

// region is_function
#if __LIGHTCXX_USE_BUILTIN(__is_function)

template<class _T>
struct is_function : bool_constant<__is_function(_T)> {};

template<class _T>
inline constexpr bool is_function_v = __is_function(_T);

#else

// Forward declare is_const
template<class _T>
struct is_const;

template<class _T>
inline constexpr bool is_function_v
  = !is_const<const _T>::value && !is_lvalue_reference_v<_T> && !is_rvalue_reference_v<_T>;

template<class _T>
struct is_function : bool_constant<is_function_v<_T>> {};

#endif  // endregion

// region is_member_object_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_member_object_pointer)

template<class _T>
struct is_member_object_pointer : bool_constant<__is_member_object_pointer(_T)> {};

template<class _T>
inline constexpr bool is_member_object_pointer_v = __is_member_object_pointer(_T);

#else

template<class _T>
struct is_member_object_pointer : false_type {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*> : bool_constant<!is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*const> : bool_constant<!is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*volatile> : bool_constant<!is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_object_pointer<_T _U::*const volatile> : bool_constant<!is_function_v<_T>> {};

template<class _T>
inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<_T>::value;

#endif  // endregion

// region is_member_function_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_member_function_pointer)

template<class _T>
struct is_member_function_pointer : bool_constant<__is_member_function_pointer(_T)> {};

template<class _T>
inline constexpr bool is_member_function_pointer_v = __is_member_function_pointer(_T);

#else

template<class _T>
struct is_member_function_pointer : false_type {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*> : bool_constant<is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*const> : bool_constant<is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*volatile> : bool_constant<is_function_v<_T>> {};

template<class _T, class _U>
struct is_member_function_pointer<_T _U::*const volatile> : bool_constant<is_function_v<_T>> {};

template<class _T>
inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<_T>::value;

#endif  // endregion

// region is_enum
#if __LIGHTCXX_USE_BUILTIN(__is_enum)

template<class _T>
struct is_enum : bool_constant<__is_enum(_T)> {};

template<class _T>
inline constexpr bool is_enum_v = __is_enum(_T);

#else

template<class _T>
struct is_enum : false_type {
    static_assert(_Light::_False<_T>, "std::is_enum is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_enum_v = is_enum<_T>::value;

#endif  // endregion

// region is_union
#if __LIGHTCXX_USE_BUILTIN(__is_union)

template<class _T>
struct is_union : bool_constant<__is_union(_T)> {};

template<class _T>
inline constexpr bool is_union_v = __is_union(_T);

#else

template<class _T>
struct is_union : false_type {
    static_assert(_Light::_False<_T>, "std::is_union is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_union_v = is_union<_T>::value;

#endif  // endregion

// region is_class
#if __LIGHTCXX_USE_BUILTIN(__is_class)

template<class _T>
struct is_class : bool_constant<__is_class(_T)> {};

template<class _T>
inline constexpr bool is_class_v = __is_class(_T);

#else

template<class _T>
struct is_class : false_type {
    static_assert(_Light::_False<_T>, "std::is_class is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_class_v = is_class<_T>::value;

#endif  // endregion

// endregion

// region [meta.unary.comp]

// region is_reference
#if __LIGHTCXX_USE_BUILTIN(__is_reference)

template<class _T>
struct is_reference : bool_constant<__is_reference(_T)> {};

template<class _T>
inline constexpr bool is_reference_v = __is_reference(_T);

#else

template<class _T>
struct is_reference : false_type {};

template<class _T>
struct is_reference<_T&> : true_type {};

template<class _T>
struct is_reference<_T&&> : true_type {};

template<class _T>
inline constexpr bool is_reference_v = is_reference<_T>::value;

#endif  // endregion

// region is_arithmetic
#if __LIGHTCXX_USE_BUILTIN(__is_arithmetic)

template<class _T>
struct is_arithmetic : bool_constant<__is_arithmetic(_T)> {};

template<class _T>
inline constexpr bool is_arithmetic_v = __is_arithmetic(_T);

#else

template<class _T>
inline constexpr bool is_arithmetic_v = is_integral_v<_T> || is_floating_point_v<_T>;

template<class _T>
struct is_arithmetic : bool_constant<is_arithmetic_v<_T>> {};

#endif  // endregion

// region is_fundamental
#if __LIGHTCXX_USE_BUILTIN(__is_fundamental)

template<class _T>
struct is_fundamental : bool_constant<__is_fundamental(_T)> {};

template<class _T>
inline constexpr bool is_fundamental_v = __is_fundamental(_T);

#else

template<class _T>
inline constexpr bool is_fundamental_v
  = is_void_v<_T> || is_null_pointer_v<_T> || is_integral_v<_T> || is_floating_point_v<_T>;

template<class _T>
struct is_fundamental : bool_constant<is_fundamental_v<_T>> {};

#endif  // endregion

// region is_object
#if __LIGHTCXX_USE_BUILTIN(__is_object)

template<class _T>
struct is_object : bool_constant<__is_object(_T)> {};

template<class _T>
inline constexpr bool is_object_v = __is_object(_T);

#else

// clang-format off
template<class _T>
inline constexpr bool is_object_v
  = is_null_pointer_v<_T>
    || is_integral_v<_T>
    || is_floating_point_v<_T>
    || is_enum_v<_T>
    || is_pointer_v<_T>
    || is_member_object_pointer_v<_T>
    || is_member_function_pointer_v<_T>
    || is_array_v<_T>
    || is_union_v<_T>
    || is_class_v<_T>;
// clang-format on

template<class _T>
struct is_object : bool_constant<is_object_v<_T>> {};

#endif  // endregion

// region is_scalar
#if __LIGHTCXX_USE_BUILTIN(__is_scalar)

template<class _T>
struct is_scalar : bool_constant<__is_scalar(_T)> {};

template<class _T>
inline constexpr bool is_scalar_v = __is_scalar(_T);

#else

// clang-format off
template<class _T>
inline constexpr bool is_scalar_v
  = is_null_pointer_v<_T>
    || is_integral_v<_T>
    || is_floating_point_v<_T>
    || is_enum_v<_T>
    || is_pointer_v<_T>
    || is_member_object_pointer_v<_T>
    || is_member_function_pointer_v<_T>;
// clang-format on

template<class _T>
struct is_scalar : bool_constant<is_scalar_v<_T>> {};

#endif  // endregion

// region is_compound
#if __LIGHTCXX_USE_BUILTIN(__is_compound)

template<class _T>
struct is_compound : bool_constant<__is_compound(_T)> {};

template<class _T>
inline constexpr bool is_compound_v = __is_compound(_T);

#else

template<class _T>
struct is_compound : bool_constant<!is_fundamental_v<_T>> {};

template<class _T>
inline constexpr bool is_compound_v = !is_fundamental_v<_T>;

#endif  // endregion

// region is_member_pointer
#if __LIGHTCXX_USE_BUILTIN(__is_member_pointer)

template<class _T>
struct is_member_pointer : bool_constant<__is_member_pointer(_T)> {};

template<class _T>
inline constexpr bool is_member_pointer_v = __is_member_pointer(_T);

#else

template<class _T>
struct is_member_pointer
        : bool_constant<is_member_object_pointer_v<_T> || is_member_function_pointer_v<_T>> {};

template<class _T>
inline constexpr bool is_member_pointer_v
  = is_member_object_pointer_v<_T> || is_member_function_pointer_v<_T>;

#endif  // endregion

// endregion

// region [meta.unary.prop]

// region is_const
#if __LIGHTCXX_USE_BUILTIN(__is_const)

template<class _T>
struct is_const : bool_constant<__is_const(_T)> {};

template<class _T>
inline constexpr bool is_const_v = __is_const(_T);

#else

template<class _T>
struct is_const : false_type {};

template<class _T>
struct is_const<_T const> : true_type {};

template<class _T>
inline constexpr bool is_const_v = is_const<_T>::value;

#endif  // endregion

// region is_volatile
#if __LIGHTCXX_USE_BUILTIN(__is_volatile)

template<class _T>
struct is_volatile : bool_constant<__is_volatile(_T)> {};

template<class _T>
inline constexpr bool is_volatile_v = __is_volatile(_T);

#else

template<class _T>
struct is_volatile : false_type {};

template<class _T>
struct is_volatile<_T volatile> : true_type {};

template<class _T>
inline constexpr bool is_volatile_v = is_volatile<_T>::value;

#endif  // endregion

// is_trivial and is_trivially_copyable are implemented after the is_trivially_*able traits.

// region is_standard_layout
#if __LIGHTCXX_USE_BUILTIN(__is_standard_layout)

template<class _T>
struct is_standard_layout : bool_constant<__is_standard_layout(_T)> {};

template<class _T>
inline constexpr bool is_standard_layout_v = __is_standard_layout(_T);

#else

template<class _T>
struct is_standard_layout : false_type {
    static_assert(_Light::_False<_T>, "std::is_standard_layout is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_standard_layout_v = is_standard_layout<_T>::value;

#endif  // endregion

// region is_empty
#if __LIGHTCXX_USE_BUILTIN(__is_empty)

template<class _T>
struct is_empty : bool_constant<__is_empty(_T)> {};

template<class _T>
inline constexpr bool is_empty_v = __is_empty(_T);

#else

template<class _T>
struct is_empty : false_type {
    static_assert(_Light::_False<_T>, "std::is_empty is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_empty_v = is_empty<_T>::value;

#endif  // endregion

// region is_polymorphic
#if __LIGHTCXX_USE_BUILTIN(__is_polymorphic)

template<class _T>
struct is_polymorphic : bool_constant<__is_polymorphic(_T)> {};

template<class _T>
inline constexpr bool is_polymorphic_v = __is_polymorphic(_T);

#else

// clang-format off
template<class _T>
inline constexpr bool is_polymorphic_v = requires {
    { dynamic_cast<const volatile void*>(declval<_T*>()) };
};

template<class _T>
struct is_polymorphic: bool_constant<requires {
    { dynamic_cast<const volatile void*>(declval<_T*>()) };
}> {};
// clang-format on

#endif  // endregion

// region is_abstract
#if __LIGHTCXX_USE_BUILTIN(__is_abstract)

template<class _T>
struct is_abstract : bool_constant<__is_abstract(_T)> {};

template<class _T>
inline constexpr bool is_abstract_v = __is_abstract(_T);

#else

template<class _T>
struct is_abstract : false_type {
    static_assert(_Light::_False<_T>, "std::is_abstract is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_abstract_v = is_abstract<_T>::value;

#endif  // endregion

// region is_final
#if __LIGHTCXX_USE_BUILTIN(__is_final)

template<class _T>
struct is_final : bool_constant<__is_final(_T)> {};

template<class _T>
inline constexpr bool is_final_v = __is_final(_T);

#else

template<class _T>
struct is_final : false_type {
    static_assert(_Light::_False<_T>, "std::is_final is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_final_v = is_final<_T>::value;

#endif  // endregion

// region is_aggregate
#if __LIGHTCXX_USE_BUILTIN(__is_aggregate)

template<class _T>
struct is_aggregate : bool_constant<__is_aggregate(_T)> {};

template<class _T>
inline constexpr bool is_aggregate_v = __is_aggregate(_T);

#else

template<class _T>
struct is_aggregate : false_type {
    static_assert(_Light::_False<_T>, "std::is_aggregate is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_aggregate_v = is_aggregate<_T>::value;

#endif  // endregion

// region is_signed
#if __LIGHTCXX_USE_BUILTIN(__is_signed)

// It seems like Clang's implementation of the trait does not check if the type is arithmetic,
// since it returns true for some types of enums.
template<class _T>
struct is_signed : bool_constant<__is_signed(_T) && is_arithmetic_v<_T>> {};

template<class _T>
inline constexpr bool is_signed_v = __is_signed(_T) && is_arithmetic_v<_T>;

#else

template<class _T>
struct is_signed : false_type {};

// clang-format off
template<class _T> requires is_arithmetic_v<_T>
struct is_signed<_T> : bool_constant<_T(-1) < _T(0)> {};
// clang-format on

template<class _T>
inline constexpr bool is_signed_v = false;

// clang-format off
template<class _T> requires is_arithmetic_v<_T>
inline constexpr bool is_signed_v<_T> = (_T(-1) < _T(0));
// clang-format on

#endif  // endregion

// region is_unsigned
#if __LIGHTCXX_USE_BUILTIN(__is_unsigned)

template<class _T>
struct is_unsigned : bool_constant<__is_unsigned(_T) && is_arithmetic_v<_T>> {};

template<class _T>
inline constexpr bool is_unsigned_v = __is_unsigned(_T) && is_arithmetic_v<_T>;

#else

template<class _T>
struct is_unsigned : false_type {};

// clang-format off
template<class _T> requires is_arithmetic_v<_T>
struct is_unsigned<_T> : bool_constant<_T(0) < _T(-1)> {};
// clang-format on

template<class _T>
inline constexpr bool is_unsigned_v = false;

// clang-format off
template<class _T> requires is_arithmetic_v<_T>
inline constexpr bool is_unsigned_v<_T> = (_T(0) < _T(-1));
// clang-format on

#endif  // endregion

// region is_bounded_array
template<class _T>
struct is_bounded_array : false_type {};

template<class _T, size_t _N>
struct is_bounded_array<_T[_N]> : true_type {};

template<class _T>
inline constexpr bool is_bounded_array_v = false;

template<class _T, size_t _N>
inline constexpr bool is_bounded_array_v<_T[_N]> = true;
// endregion

// region is_unbounded_array
template<class _T>
struct is_unbounded_array : false_type {};

template<class _T>
struct is_unbounded_array<_T[]> : true_type {};

template<class _T>
inline constexpr bool is_unbounded_array_v = false;

template<class _T>
inline constexpr bool is_unbounded_array_v<_T[]> = true;
// endregion

// region is_constructible
#if __LIGHTCXX_USE_BUILTIN(__is_constructible)

template<class _T, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_T, _Args...)> {};

template<class _T, class... _Args>
inline constexpr bool is_constructible_v = __is_constructible(_T, _Args...);

#else

template<class _T>
struct remove_cv;

template<class _T>
struct add_pointer;

// clang-format off

template<class _T, class... _Args>
inline constexpr bool is_constructible_v = requires {
    { new _T(declval<_Args>()...) } -> same_as<typename add_pointer<_T>::type>;
};

template<class _T, class _From>
inline constexpr bool is_constructible_v<_T&, _From> = requires {
    { static_cast<_T&>(declval<_From>()) };
};

template<class _T, class _From>
inline constexpr bool is_constructible_v<_T&&, _From> = requires {
    { static_cast<_T&&>(declval<_From>()) };
};

template<class _T, class _From>
inline constexpr bool is_constructible_v<_T&&, _From&> = is_function_v<_T> &&
  is_same_v<typename remove_cv<_T>::type, typename remove_cv<_From>::type>;

template<class _T, size_t _N>
inline constexpr bool is_constructible_v<_T[_N]> = is_constructible_v<_T>;

template<class _T, class... _Args>
struct is_constructible : bool_constant<is_constructible_v<_T, _Args...>> {};

// clang-format on

#endif  // endregion

// region is_default_constructible

template<class _T>
struct is_default_constructible : bool_constant<is_constructible_v<_T>> {};

template<class _T>
inline constexpr bool is_default_constructible_v = is_constructible_v<_T>;

// endregion

// region is_copy_constructible

template<class _T>
struct add_lvalue_reference;

template<class _T>
struct is_copy_constructible
        : bool_constant<is_constructible_v<_T, typename add_lvalue_reference<const _T>::type>> {};

template<class _T>
inline constexpr bool is_copy_constructible_v
  = is_constructible_v<_T, typename add_lvalue_reference<const _T>::type>;

// endregion

// region is_move_constructible

template<class _T>
struct add_rvalue_reference;

template<class _T>
struct is_move_constructible
        : bool_constant<is_constructible_v<_T, typename add_rvalue_reference<_T>::type>> {};

template<class _T>
inline constexpr bool is_move_constructible_v
  = is_constructible_v<_T, typename add_rvalue_reference<_T>::type>;

// endregion

// region is_assignable
#if __LIGHTCXX_USE_BUILTIN(__is_assignable)

template<class _T, class _U>
struct is_assignable : bool_constant<__is_assignable(_T, _U)> {};

template<class _T, class _U>
inline constexpr bool is_assignable_v = __is_assignable(_T, _U);

#else

// clang-format off
template<class _T, class _U>
struct is_assignable : bool_constant<requires { { declval<_T>() = declval<_U>() }; }> {};

template<class _T, class _U>
inline constexpr bool is_assignable_v = requires { { declval<_T>() = declval<_U>() }; };
    // clang-format on

#endif  // endregion

// region is_copy_assignable
template<class _T>
struct is_copy_assignable
        : bool_constant<is_assignable_v<typename add_lvalue_reference<_T>::type,
                                        typename add_lvalue_reference<const _T>::type>> {};

template<class _T>
inline constexpr bool is_copy_assignable_v
  = is_assignable_v<typename add_lvalue_reference<_T>::type,
                    typename add_lvalue_reference<const _T>::type>;
// endregion

// region is_move_assignable
template<class _T>
struct is_move_assignable
        : bool_constant<is_assignable_v<typename add_lvalue_reference<_T>::type,
                                        typename add_rvalue_reference<_T>::type>> {};

template<class _T>
inline constexpr bool is_move_assignable_v
  = is_assignable_v<typename add_lvalue_reference<_T>::type,
                    typename add_rvalue_reference<_T>::type>;
// endregion

// is_swappable and is_swappable_with are implemented after the is_nothrow_*able traits.

// region is_destructible
#if __LIGHTCXX_USE_BUILTIN(__is_destructible)
template<class _T>
struct is_destructible : bool_constant<__is_destructible(_T)> {};

template<class _T>
inline constexpr bool is_destructible_v = __is_destructible(_T);
#else
template<class _T>
struct remove_all_extents;

template<class _T>
inline constexpr bool is_destructible_v = []() {
    if constexpr (is_reference_v<_T>) {
        return true;
    } else {
        using _U = typename remove_all_extents<_T>::type;
        return requires {
            {declval<_U&>().~_U()};
        };
    }
}();

template<class _T>
struct is_destructible : bool_constant<is_destructible_v<_T>> {};
#endif  // endregion

// region is_trivially_constructible
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)
template<class _T, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_T, _Args...)> {};

template<class _T, class... _Args>
inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_T, _Args...);
#else
template<class _T, class...>
struct is_trivially_constructible : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_constructible is not supported on this compiler.");
};

template<class _T, class... _Args>
inline constexpr bool is_trivially_constructible_v
  = is_trivially_constructible<_T, _Args...>::value;
#endif  // endregion

// region is_trivially_default_constructible
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)
template<class _T>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_T)> {};

template<class _T>
inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_T);
#else
template<class _T>
struct is_trivially_default_constructible : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_default_constructible is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_default_constructible_v
  = is_trivially_default_constructible<_T>::value;
#endif  // endregion

// region is_trivially_copy_constructible
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)
template<class _T>
struct is_trivially_copy_constructible : bool_constant<__is_trivially_constructible(
                                           _T, typename add_lvalue_reference<const _T>::type)> {};

template<class _T>
inline constexpr bool is_trivially_copy_constructible_v
  = __is_trivially_constructible(_T, typename add_lvalue_reference<const _T>::type);
#else
template<class _T>
struct is_trivially_copy_constructible : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_copy_constructible is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_copy_constructible_v
  = is_trivially_copy_constructible<_T>::value;
#endif  // endregion

// region is_trivially_move_constructible
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)
template<class _T>
struct is_trivially_move_constructible
        : bool_constant<__is_trivially_constructible(_T, typename add_rvalue_reference<_T>::type)> {
};

template<class _T>
inline constexpr bool is_trivially_move_constructible_v
  = __is_trivially_constructible(_T, typename add_rvalue_reference<_T>::type);
#else
template<class _T>
struct is_trivially_move_constructible : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_move_constructible is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_move_constructible_v
  = is_trivially_move_constructible<_T>::value;
#endif  // endregion

// region is_trivially_assignable
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_assignable)
template<class _T, class _U>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_T, _U)> {};

template<class _T, class _U>
inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_T, _U);
#else
template<class _T, class>
struct is_trivially_assignable : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_assignable is not supported on this compiler.");
};

template<class _T, class _U>
inline constexpr bool is_trivially_assignable_v = is_trivially_assignable<_T, _U>::value;
#endif  // endregion

// region is_trivially_copy_assignable
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_assignable)
template<class _T>
struct is_trivially_copy_assignable
        : bool_constant<__is_trivially_assignable(typename add_lvalue_reference<_T>::type,
                                                  typename add_lvalue_reference<const _T>::type)> {
};

template<class _T>
inline constexpr bool is_trivially_copy_assignable_v
  = __is_trivially_assignable(typename add_lvalue_reference<_T>::type,
                              typename add_lvalue_reference<const _T>::type);
#else
template<class _T>
struct is_trivially_copy_assignable : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_copy_assignable is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_T>::value;
#endif  // endregion

// region is_trivially_move_assignable
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_assignable)
template<class _T>
struct is_trivially_move_assignable
        : bool_constant<__is_trivially_assignable(typename add_lvalue_reference<_T>::type,
                                                  typename add_rvalue_reference<_T>::type)> {};

template<class _T>
inline constexpr bool is_trivially_move_assignable_v
  = __is_trivially_assignable(typename add_lvalue_reference<_T>::type,
                              typename add_rvalue_reference<_T>::type);
#else
template<class _T>
struct is_trivially_move_assignable : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_move_assignable is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_T>::value;
#endif  // endregion

// region is_trivially_destructible
#if __LIGHTCXX_USE_BUILTIN(__is_trivially_destructible)
template<class _T>
struct is_trivially_destructible : false_type {};

// clang-format off
template<class _T> requires is_destructible_v<_T>
struct is_trivially_destructible<_T> : bool_constant<__is_trivially_destructible(_T)> {};
// clang-format on

template<class _T>
inline constexpr bool is_trivially_destructible_v = false;

// clang-format off
template<class _T> requires is_destructible_v<_T>
inline constexpr bool is_trivially_destructible_v<_T> = __is_trivially_destructible(_T);
// clang-format on
#else
template<class _T>
struct is_trivially_destructible : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_destructible is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<_T>::value;
#endif  // endregion

// region is_trivially_copyable
// TODO: Investigate further about Clang's __is_trivially_copyable builtin, but at first sight it
//  doesn't seem fully standard compliant (says a class with all copy/move constructors &
//  assignment operators deleted is trivially copyable, which contradicts [class.prop] paragraph
//  1.1).

#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)                                           \
  && __LIGHTCXX_USE_BUILTIN(__is_trivially_assignable)                                             \
  && __LIGHTCXX_USE_BUILTIN(__is_trivially_destructible) && __LIGHTCXX_USE_BUILTIN(__is_class)     \
  && __LIGHTCXX_USE_BUILTIN(__is_enum)
template<class _T>
struct remove_cv;
template<class _T>
struct remove_all_extents;

template<class _T>
constexpr bool is_trivially_copyable_v = []() {
    using _U =
      typename remove_cv<typename remove_all_extents<typename remove_cv<_T>::type>::type>::type;
    return is_scalar_v<_U>
      || (is_class_v<_U>
         // class.prop # 1.1
         && (is_copy_constructible_v<_U>
             || is_copy_assignable_v<_U>
             || is_move_constructible_v<_U>
             || is_move_assignable_v<_U>)
         // class.prop # 1.2
         && (!is_copy_constructible_v<_U> || is_trivially_copy_constructible_v<_U>)
         && (!is_copy_assignable_v<_U> || is_trivially_copy_assignable_v<_U>)
         && (!is_move_constructible_v<_U> || is_trivially_move_constructible_v<_U>)
         && (!is_move_assignable_v<_U> || is_trivially_move_assignable_v<_U>)
         //  class.prop # 1.3
         && is_trivially_destructible_v<_U>);
}();

template<class _T>
struct is_trivially_copyable : bool_constant<is_trivially_copyable_v<_T>> {};

#else

template<class _T>
struct is_trivially_copyable : false_type {
    static_assert(_Light::_False<_T>,
                  "std::is_trivially_copyable is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<_T>::value;

#endif  // endregion

// region is_trivial
// TODO: Investigate further about Clang's __is_trivial builtin, but at first sight it doesn't seem
//  fully standard compliant (says a class with all copy/move constructors &
//  assignment operators deleted is trivial, which contradicts [class.prop] paragraph 1.1).

#if __LIGHTCXX_USE_BUILTIN(__is_trivially_constructible)                                           \
  && __LIGHTCXX_USE_BUILTIN(__is_trivially_assignable)                                             \
  && __LIGHTCXX_USE_BUILTIN(__is_trivially_destructible) && __LIGHTCXX_USE_BUILTIN(__is_class)     \
  && __LIGHTCXX_USE_BUILTIN(__is_enum)

template<class _T>
struct is_trivial
        : bool_constant<is_trivially_copyable_v<_T> && is_trivially_default_constructible_v<_T>> {};

template<class _T>
inline constexpr bool is_trivial_v
  = is_trivially_copyable_v<_T>&& is_trivially_default_constructible_v<_T>;

#else

template<class _T>
struct is_trivial : false_type {
    static_assert(_Light::_False<_T>, "std::is_trivial is not supported on this compiler.");
};

template<class _T>
inline constexpr bool is_trivial_v = is_trivial<_T>::value;

#endif  // endregion

// region is_nothrow_constructible
#if __LIGHTCXX_USE_BUILTIN(__is_nothrow_constructible)
template<class _T, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_T, _Args...)> {};

template<class _T, class... _Args>
constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_T, _Args...);
#else
// clang-format off
template<class _T, class... _Args>
inline constexpr bool is_nothrow_constructible_v = requires {
    { new _T(declval<_Args>()...) } -> same_as<typename add_pointer<_T>::type>;
    { _T(declval<_Args>()...) } noexcept;
};

template<class _T, class _From>
inline constexpr bool is_nothrow_constructible_v<_T&, _From> = requires {
    { static_cast<_T&>(declval<_From>()) } noexcept;
};

template<class _T, class _From>
inline constexpr bool is_nothrow_constructible_v<_T&&, _From> = requires {
    { static_cast<_T&&>(declval<_From>()) } noexcept;
};

template<class _T, class _From>
inline constexpr bool is_nothrow_constructible_v<_T&&, _From&> = is_function_v<_T> &&
  is_same_v<typename remove_cv<_T>::type, typename remove_cv<_From>::type>;

template<class _T, size_t _N>
inline constexpr bool is_nothrow_constructible_v<_T[_N]> = is_nothrow_constructible_v<_T>;

template<class _T, class... _Args>
struct is_nothrow_constructible : bool_constant<is_nothrow_constructible_v<_T, _Args...>> {};
// clang-format on
#endif  // endregion

// region is_nothrow_default_constructible

template<class _T>
struct is_nothrow_default_constructible : bool_constant<is_nothrow_constructible_v<_T>> {};

template<class _T>
inline constexpr bool is_nothrow_default_constructible_v = is_nothrow_constructible_v<_T>;

// endregion

// region is_nothrow_copy_constructible

template<class _T>
struct add_lvalue_reference;

template<class _T>
struct is_nothrow_copy_constructible
        : bool_constant<
            is_nothrow_constructible_v<_T, typename add_lvalue_reference<const _T>::type>> {};

template<class _T>
inline constexpr bool is_nothrow_copy_constructible_v
  = is_nothrow_constructible_v<_T, typename add_lvalue_reference<const _T>::type>;

// endregion

// region is_nothrow_move_constructible

template<class _T>
struct add_rvalue_reference;

template<class _T>
struct is_nothrow_move_constructible
        : bool_constant<is_nothrow_constructible_v<_T, typename add_rvalue_reference<_T>::type>> {};

template<class _T>
inline constexpr bool is_nothrow_move_constructible_v
  = is_nothrow_constructible_v<_T, typename add_rvalue_reference<_T>::type>;

// endregion

// TODO: is_swappable_with, is_swappable.

// endregion

template<class _T>
struct remove_reference {
    using type = _T;
};

template<class _T>
struct remove_reference<_T&> {
    using type = _T;
};

template<class _T>
struct remove_reference<_T&&> {
    using type = _T;
};

template<class _T>
using remove_reference_t = typename remove_reference<_T>::type;

template<class _T>
struct remove_cv {
    using type = _T;
};

template<class _T>
struct remove_cv<const _T> {
    using type = _T;
};

template<class _T>
struct remove_cv<volatile _T> {
    using type = _T;
};

template<class _T>
struct remove_cv<const volatile _T> {
    using type = _T;
};

template<class _T>
using remove_cv_t = typename remove_cv<_T>::type;

template<class _T>
struct add_cv {
    using type = const volatile _T;
};

template<class _T>
using add_cv_t = typename add_cv<_T>::type;

template<class _T>
struct add_const {
    using type = const _T;
};

template<class _T>
using add_const_t = typename add_const<_T>::type;

template<class _T>
struct add_volatile {
    using type = volatile _T;
};

template<class _T>
using add_volatile_t = typename add_volatile<_T>::type;

template<class _T>
struct remove_extent {
    using type = _T;
};

template<class _T>
struct remove_extent<_T[]> {
    using type = _T;
};

template<class _T, size_t _N>
struct remove_extent<_T[_N]> {
    using type = _T;
};

template<class _T>
using remove_extent_t = typename remove_extent<_T>::type;

template<class _T>
struct remove_all_extents {
    using type = _T;
};

template<class _T>
struct remove_all_extents<_T[]> {
    using type = typename remove_all_extents<_T>::type;
};

template<class _T, size_t _N>
struct remove_all_extents<_T[_N]> {
    using type = typename remove_all_extents<_T>::type;
};

template<class _T>
using remove_all_extents_t = typename remove_all_extents<_T>::type;

template<class _T>
struct add_lvalue_reference {
    using type = _T;
};

template<_Light::_Referenceable _T>
struct add_lvalue_reference<_T> {
    using type = remove_reference_t<_T>&;
};

template<class _T>
using add_lvalue_reference_t = typename add_lvalue_reference<_T>::type;

template<class _T>
struct add_rvalue_reference {
    using type = _T;
};

template<_Light::_Referenceable _T>
struct add_rvalue_reference<_T> {
    using type = remove_reference_t<_T>&&;
};

template<class _T>
using add_rvalue_reference_t = typename add_rvalue_reference<_T>::type;

template<class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {};

template<class _Base, class _Derived>
inline constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;

template<class _From, class _To>
struct is_convertible : bool_constant<__is_convertible(_From, _To)> {};

template<class _From, class _To>
inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;

template<class _T>
struct add_pointer {
    using type = _T;
};

// clang-format off
template<class _T> requires _Light::_Referenceable<_T> || is_void_v<_T>
struct add_pointer<_T> {
    using type = remove_reference_t<_T>*;
};
// clang-format on

template<class _T>
using add_pointer_t = typename add_pointer<_T>::type;

template<bool _B, class _T, class _F>
struct conditional {
    using type = _T;
};

template<class _T, class _F>
struct conditional<false, _T, _F> {
    using type = _F;
};

template<bool _B, class _T, class _F>
using conditional_t = typename conditional<_B, _T, _F>::type;

template<class _T>
struct decay {
  private:
    using _U = remove_reference_t<_T>;

  public:
    using type
      = conditional_t<is_array_v<_U>, remove_extent_t<_U>*,
                      conditional_t<is_function_v<_U>, add_pointer_t<_U>, remove_cv_t<_U>>>;
};

template<class _T>
using decay_t = typename decay<_T>::type;

}  // namespace std

#undef __UNARY_TRAIT_TRUE_FOR_ALL_CV
#undef __LIGHTCXX_USE_BUILTIN

#endif

#ifndef _LIGHTCXX_GUARD_SYSTEM_ERROR
#define _LIGHTCXX_GUARD_SYSTEM_ERROR

#include <cerrno>
#include <compare>
#include <stdexcept>

namespace std {

template<class _T>
struct is_error_code_enum : public false_type {};
template<class _T>
inline constexpr bool is_error_code_enum_v = is_error_code_enum<_T>::value;

template<class _T>
struct is_error_condition_enum : public false_type {};
template<class _T>
inline constexpr bool is_error_condition_enum_v = is_error_condition_enum<_T>::value;

enum class errc {
    address_family_not_supported = EAFNOSUPPORT,
    address_in_use = EADDRINUSE,
    address_not_available = EADDRNOTAVAIL,
    already_connected = EISCONN,
    argument_list_too_long = E2BIG,
    argument_out_of_domain = EDOM,
    bad_address = EFAULT,
    bad_file_descriptor = EBADF,
    bad_message = EBADMSG,
    broken_pipe = EPIPE,
    connection_aborted = ECONNABORTED,
    connection_already_in_progress = EALREADY,
    connection_refused = ECONNREFUSED,
    connection_reset = ECONNRESET,
    cross_device_link = EXDEV,
    destination_address_required = EDESTADDRREQ,
    device_or_resource_busy = EBUSY,
    directory_not_empty = ENOTEMPTY,
    executable_format_error = ENOEXEC,
    file_exists = EEXIST,
    file_too_large = EFBIG,
    filename_too_long = ENAMETOOLONG,
    function_not_supported = ENOSYS,
    host_unreachable = EHOSTUNREACH,
    identifier_removed = EIDRM,
    illegal_byte_sequence = EILSEQ,
    inappropriate_io_control_operation = ENOTTY,
    interrupted = EINTR,
    invalid_argument = EINVAL,
    invalid_seek = ESPIPE,
    io_error = EIO,
    is_a_directory = EISDIR,
    message_size = EMSGSIZE,
    network_down = ENETDOWN,
    network_reset = ENETRESET,
    network_unreachable = ENETUNREACH,
    no_buffer_space = ENOBUFS,
    no_child_process = ECHILD,
    no_link = ENOLINK,
    no_lock_available = ENOLCK,
    no_message_available = ENODATA,
    no_message = ENOMSG,
    no_protocol_option = ENOPROTOOPT,
    no_space_on_device = ENOSPC,
    no_stream_resources = ENOSR,
    no_such_device_or_address = ENXIO,
    no_such_device = ENODEV,
    no_such_file_or_directory = ENOENT,
    no_such_process = ESRCH,
    not_a_directory = ENOTDIR,
    not_a_socket = ENOTSOCK,
    not_a_stream = ENOSTR,
    not_connected = ENOTCONN,
    not_enough_memory = ENOMEM,
    not_supported = ENOTSUP,
    operation_canceled = ECANCELED,
    operation_in_progress = EINPROGRESS,
    operation_not_permitted = EPERM,
    operation_not_supported = EOPNOTSUPP,
    operation_would_block = EWOULDBLOCK,
    owner_dead = EOWNERDEAD,
    permission_denied = EACCES,
    protocol_error = EPROTO,
    protocol_not_supported = EPROTONOSUPPORT,
    read_only_file_system = EROFS,
    resource_deadlock_would_occur = EDEADLK,
    resource_unavailable_try_again = EAGAIN,
    result_out_of_range = ERANGE,
    state_not_recoverable = ENOTRECOVERABLE,
    stream_timeout = ETIME,
    text_file_busy = ETXTBSY,
    timed_out = ETIMEDOUT,
    too_many_files_open_in_system = ENFILE,
    too_many_files_open = EMFILE,
    too_many_links = EMLINK,
    too_many_symbolic_link_levels = ELOOP,
    value_too_large = EOVERFLOW,
    wrong_protocol_type = EPROTOTYPE,
};

template<>
struct is_error_condition_enum<errc> : true_type {};

class error_code;
class error_condition;

class error_category {
  public:
    constexpr error_category() noexcept = default;
    virtual ~error_category();
    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;
    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int __ev) const noexcept;
    virtual bool equivalent(int __code, const error_condition& __condition) const noexcept;
    virtual bool equivalent(const error_code& __code, int __condition) const noexcept;
    // TODO: After implementing string.
    //    virtual string message(int __ev) const = 0;

    bool operator==(const error_category& __rhs) const noexcept;
    strong_ordering operator<=>(const error_category& __rhs) const noexcept;
};
const error_category& generic_category() noexcept;
const error_category& system_category() noexcept;

class error_code {
  public:
    error_code() noexcept;
    error_code(int __v, const error_category& __c) noexcept;

    template<class _E>
        requires(is_error_code_enum_v<_E>)
    error_code(_E __e) noexcept
            : error_code(static_cast<int>(__e), generic_category()) {}

    void assign(int __v, const error_category& __c) noexcept;

    template<class _E>
        requires(is_error_code_enum_v<_E>)
    error_code& operator=(_E __e) noexcept {
        __val = static_cast<int>(__e);
        __cat = addressof(generic_category());
        return *this;
    }

    void clear() noexcept;

    int value() const noexcept;
    const error_category& category() const noexcept;
    error_condition default_error_condition() const noexcept;
    // TODO: After implementing string.
    //    string message() const;
    explicit operator bool() const noexcept;

  private:
    int __val;
    const error_category* __cat;
};
error_code make_error_code(errc __e) noexcept;

// TODO: After implementing iostreams
// template<class _Char, class _Traits>
// basic_ostream<_Char, _Traits>& operator<<(basic_ostream<_Char, _Traits>& __os, const error_code& __ec) {
//    return __os << __ec.category().name() << ':' << __ec.value();
//}

class error_condition {
  public:
    error_condition() noexcept;
    error_condition(int __v, const error_category& __c) noexcept;

    template<class _E>
        requires(is_error_condition_enum_v<_E>)
    error_condition(_E __e) noexcept
            : error_condition(static_cast<int>(__e), generic_category()) {}

    void assign(int __v, const error_category& __c) noexcept;

    template<class _E>
        requires(is_error_condition_enum_v<_E>)
    error_condition& operator=(_E __e) noexcept {
        __val = static_cast<int>(__e);
        __cat = addressof(generic_category());
        return *this;
    }

    void clear() noexcept;

    int value() const noexcept;
    const error_category& category() const noexcept;
    // TODO: After implementing string.
    //    string message() const;
    explicit operator bool() const noexcept;

  private:
    int __val;
    const error_category* __cat;
};
error_condition make_error_condition(errc __e) noexcept;

bool operator==(const error_code& __lhs, const error_code& __rhs) noexcept;
bool operator==(const error_code& __lhs, const error_condition& __rhs) noexcept;
bool operator==(const error_condition& __lhs, const error_condition& __rhs) noexcept;
strong_ordering operator<=>(const error_code& __lhs, const error_code& __rhs) noexcept;
strong_ordering operator<=>(const error_condition& __lhs, const error_condition& __rhs) noexcept;

// TODO: After hash implementation for integers.
//template<class _T>
//struct hash;
//template<>
//struct hash<error_code>;
//template<>
//struct hash<error_condition>;

class system_error : public runtime_error {
  public:
    // TODO: After implementing string.
    //    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    // TODO: After implementing string.
    //    system_error(int __ec, const error_category& __cat, const string& __what_arg);
    system_error(int __ec, const error_category& __cat, const char* __what_arg);
    system_error(int __ec, const error_category& __cat);
    const error_code& code() const noexcept;
    const char* what() const noexcept override;
};

}  // namespace std

#endif

#ifndef _LIGHTCXX_GUARD_UTILITY
#define _LIGHTCXX_GUARD_UTILITY

#include <compare>
#include <initializer_list>
#include <limits>
#include <type_traits>

namespace std {

// region [utility.swap]
using ::std::swap;  // defined in <type_traits>
// endregion

// region [utility.exchange]
template<class _T, class _U = _T>
constexpr _T exchange(_T& __obj, _U&& __new_val) noexcept(is_nothrow_move_constructible_v<_T>&& is_nothrow_assignable_v<_T&, decltype(__new_val)>)
    requires(
      is_move_constructible_v<_T> && is_assignable_v<_T&, decltype(__new_val)>)
{
    _T __old_val{move(__obj)};
    __obj = forward<_U>(__new_val);
    return __old_val;
}
// endregion

// region [forward]
using ::std::forward;  // defined in <type_traits>

using ::std::move;  // defined in <type_traits>

template<class _T>
constexpr const _T& move_if_noexcept(_T& __x) noexcept {
    return __x;
}

template<class _T>
    requires is_nothrow_move_constructible_v<_T>
constexpr _T&& move_if_noexcept(_T& __x) noexcept {
    return move(__x);
}
// endregion

// region [utility.as.const]
template<class _T>
constexpr add_const_t<_T>& as_const(_T& __t) noexcept {
    return __t;
}
// endregion

// region [declval]
using ::std::declval;  // defined in <type_traits>
// endregion

// region [utility.intcmp]
template<integral _T, integral _U>
constexpr bool cmp_equal(_T __t, _U __u) noexcept {
    if constexpr (is_signed_v<_T> == is_signed_v<_U>) {
        return __t == __u;
    } else if constexpr (is_signed_v<_T>) {
        return __t >= 0 && make_unsigned_t<_T>(__t) == __u;
    } else {
        return __u >= 0 && __t == make_unsigned_t<_U>(__u);
    }
}

template<integral _T, integral _U>
constexpr bool cmp_not_equal(_T __t, _U __u) noexcept {
    return !cmp_equal(__t, __u);
}

template<integral _T, integral _U>
constexpr bool cmp_less(_T __t, _U __u) noexcept {
    if constexpr (is_signed_v<_T> == is_signed_v<_U>) {
        return __t < __u;
    } else if constexpr (is_signed_v<_T>) {
        return __t < 0 || make_unsigned_t<_T>(__t) < __u;
    } else {
        return __u >= 0 && __t < make_unsigned_t<_U>(__u);
    }
}

template<integral _T, integral _U>
constexpr bool cmp_greater(_T __t, _U __u) noexcept {
    return cmp_less(__u, __t);
}

template<integral _T, integral _U>
constexpr bool cmp_less_equal(_T __t, _U __u) noexcept {
    return !cmp_greater(__t, __u);
}

template<integral _T, integral _U>
constexpr bool cmp_greater_equal(_T __t, _U __u) noexcept {
    return !cmp_less(__t, __u);
}

template<integral _R, integral _T>
constexpr bool in_range(_T __t) noexcept {
    return cmp_greater_equal(__t, numeric_limits<_R>::min()) && cmp_less_equal(__t, numeric_limits<_R>::max());
}
// endregion

// region [intseq]
template<integral _T, _T... _I>
struct integer_sequence {
    using value_type = _T;

    static constexpr size_t size() noexcept {
        return sizeof...(_I);
    }
};

template<size_t... _I>
using index_sequence = integer_sequence<size_t, _I...>;

#if _LIGHTCXX_BUILTINS_USE(__integer_pack)
template<integral _T, _T _N>
    requires(_N >= 0)
using make_integer_sequence = integer_sequence<_T, __integer_pack(_N)...>;
#elif _LIGHTCXX_BUILTINS_USE(__make_integer_seq)
template<integral _T, _T _N>
    requires(_N >= 0)
using make_integer_sequence = __make_integer_seq<integer_sequence, _T, _N>;
#else
template<integral _T, _T _N>
    requires(_N >= 0)
struct make_integer_sequence {
    static_assert(_Light::_False<_T>, "std::make_integer_sequence is not supported on this compiler.");
};
#endif

template<size_t _N>
using make_index_sequence = make_integer_sequence<size_t, _N>;

template<class... _T>
using index_sequence_for = make_integer_sequence<size_t, sizeof...(_T)>;
// endregion

// region [pair.piecewise]
struct piecewise_construct_t {
    constexpr explicit piecewise_construct_t() = default;
};
inline constexpr piecewise_construct_t piecewise_construct{};
// endregion

// region [pairs.pair]
template<class _T1, class _T2>
struct pair {
    using first_type = _T1;
    using second_type = _T2;

    _T1 first;
    _T2 second;

    pair(const pair&) = default;
    pair(pair&&) = default;

    constexpr explicit(!_Light::_HasImplicitDfltCtor<_T1> || !_Light::_HasImplicitDfltCtor<_T2>)
      pair() noexcept(is_nothrow_default_constructible_v<_T1>&& is_nothrow_default_constructible_v<_T2>)
        : first(), second() {}

    constexpr explicit(!is_convertible_v<const _T1&, _T1> || !is_convertible_v<const _T2&, _T2>)
      pair(const _T1& __first, const _T2& __second) noexcept(is_nothrow_copy_constructible_v<_T1>&& is_nothrow_copy_constructible_v<_T2>)
        : first(__first), second(__second) {}

    template<class _U1, class _U2>
    constexpr explicit(!is_convertible_v<_U1, _T1> || !is_convertible_v<_U2, _T2>)
      pair(_U1&& __first, _U2&& __second) noexcept(is_nothrow_constructible_v<_T1, _U1> && is_nothrow_constructible_v<_T2, _U2>)
        : first(forward<_U1>(__first)), second(forward<_U2>(__second)) {}

    template<class _U1, class _U2>
    constexpr explicit(!is_convertible_v<const _U1&, _T1> || !is_convertible_v<const _U2&, _T2>)
      pair(const pair<_U1, _U2>& __r) noexcept(is_nothrow_constructible_v<_T1, const _U1&> && is_nothrow_constructible_v<_T2, const _U2&>)
        : first(__r.first), second(__r.second) {}

    template<class _U1, class _U2>
    constexpr explicit(!is_convertible_v<_U1, _T1> || !is_convertible_v<_U2, _T2>)
      pair(pair<_U1, _U2>&& __r) noexcept(is_nothrow_constructible_v<_T1, _U1> && is_nothrow_constructible_v<_T2, _U2>)
        : first(forward<_U1>(__r.first)), second(forward<_U2>(__r.second)) {}

    // TODO: Add this constructor after implementing tuple
//    template<class... _Args1, class... _Args2>
//    constexpr pair(piecewise_construct_t, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
//      noexcept(is_nothrow_constructible_v<_T1, _Args1...> && is_nothrow_constructible_v<_T2, _Args2...>)
//        : pair(piecewise_construct_t{},
//               index_sequence_for<_Args1...>{}, move(__first_args),
//               index_sequence_for<_Args2...>{}, move(__second_args)) {}
//  private:
//    template<class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
//    constexpr pair(piecewise_construct_t,
//                   index_sequence<_I1...>, tuple<_Args1...> __first_args,
//                   index_sequence<_I2...>, tuple<_Args2...> __second_args)
//      noexcept(is_nothrow_constructible_v<_T1, _Args1...> && is_nothrow_constructible_v<_T2, _Args2...>)
//        : first(forward<_Args1>(get<_I1>(__first_args))...),
//          second(forward<_Args2>(get<_I2>(__second_args))...) {}
//  public:

    constexpr pair& operator=(const pair& __r)
      requires (!is_copy_assignable_v<_T1> || !is_copy_assignable_v<_T2>) = delete;

    constexpr pair& operator=(const pair& __r)
      requires is_trivially_copy_assignable_v<_T1> && is_trivially_copy_assignable_v<_T2> = default;

    constexpr pair& operator=(const pair& __r)
      noexcept(is_nothrow_copy_assignable_v<_T1> && is_nothrow_copy_assignable_v<_T2>)
      requires is_copy_assignable_v<_T1> && is_copy_assignable_v<_T2>
                && (!is_trivially_copy_assignable_v<_T1> || !is_trivially_copy_assignable_v<_T2>) {
        first = __r.first;
        second = __r.second;
        return *this;
    }

    template<class _U1, class _U2>
    constexpr pair& operator=(const pair<_U1, _U2>& __r)
      noexcept(is_nothrow_assignable_v<_T1&, const _U1&> && is_nothrow_assignable_v<_T2&, const _U2&>) {
        first = __r.first;
        second = __r.second;
        return *this;
    }

    constexpr pair& operator=(pair&& __r)
      requires is_trivially_move_assignable_v<_T1> && is_trivially_move_assignable_v<_T2> = default;

    constexpr pair& operator=(pair&& __r)
      noexcept(is_nothrow_move_assignable_v<_T1> && is_nothrow_move_assignable_v<_T2>)
      requires (!is_trivially_move_assignable_v<_T1> || !is_trivially_move_assignable_v<_T2>) {
        first = forward<_T1>(__r.first);
        second = forward<_T2>(__r.second);
        return *this;
    }

    template<class _U1, class _U2>
    constexpr pair& operator=(pair<_U1, _U2>&& __r)
      noexcept(is_nothrow_assignable_v<_T1&, _U1> && is_nothrow_assignable_v<_T2&, _U2>) {
        first = forward<_T1>(__r.first);
        second = forward<_T2>(__r.second);
        return *this;
    }

    constexpr void swap(pair& __r)
      noexcept(is_nothrow_swappable_v<_T1> && is_nothrow_swappable_v<_T2>) {
        using ::std::swap;
        swap(first, __r.first);
        swap(second, __r.second);
    }
};

template<class _T1, class _T2>
pair(_T1, _T2) -> pair<_T1, _T2>;
// endregion

// region [pairs.spec]
template<class _T1, class _T2>
constexpr bool operator==(const pair<_T1, _T2>& __l, const pair<_T1, _T2>& __r) {
    return __l.first == __r.first && __l.second == __r.second;
}

// TODO: Implement operator<=> for pairs after adding something like __synth_three_way.

template<class _T1, class _T2>
constexpr void swap(pair<_T1, _T2>& __l, pair<_T1, _T2>& __r) noexcept(noexcept(__l.swap(__r))) {
    __l.swap(__r);
}

template<class _T1, class _T2>
constexpr auto make_pair(_T1&& __first, _T2&& __second) {
    return pair<unwrap_ref_decay_t<_T1>, unwrap_ref_decay_t<_T2>>(forward<_T1>(__first), forward<_T2>(__second));
}
// endregion

// region [pair.astuple]
// TODO: Implement [pairs.astuple]
// endregion

struct in_place_t {
    constexpr explicit in_place_t() = default;
};
inline constexpr in_place_t in_place{};

template<class _T>
struct in_place_type_t {
    constexpr explicit in_place_type_t() = default;
};
template<class _T>
inline constexpr in_place_type_t<_T> in_place_type{};

template<size_t _I>
struct in_place_index_t {
    constexpr explicit in_place_index_t() = default;
};

template<size_t _I>
inline constexpr in_place_index_t<_I> in_place_index{};

}  // namespace std

#endif
